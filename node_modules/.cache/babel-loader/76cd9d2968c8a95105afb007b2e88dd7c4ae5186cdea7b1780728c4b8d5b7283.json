{"ast":null,"code":";\n(function (require, exports, module, platform) {\n  if (module) module.exports = minimatch;else exports.minimatch = minimatch;\n  if (!require) {\n    require = function (id) {\n      switch (id) {\n        case \"sigmund\":\n          return function sigmund(obj) {\n            return JSON.stringify(obj);\n          };\n        case \"path\":\n          return {\n            basename: function (f) {\n              f = f.split(/[\\/\\\\]/);\n              var e = f.pop();\n              if (!e) e = f.pop();\n              return e;\n            }\n          };\n        case \"lru-cache\":\n          return function LRUCache() {\n            // not quite an LRU, but still space-limited.\n            var cache = {};\n            var cnt = 0;\n            this.set = function (k, v) {\n              cnt++;\n              if (cnt >= 100) cache = {};\n              cache[k] = v;\n            };\n            this.get = function (k) {\n              return cache[k];\n            };\n          };\n      }\n    };\n  }\n  minimatch.Minimatch = Minimatch;\n  var LRU = require(\"lru-cache\"),\n    cache = minimatch.cache = new LRU({\n      max: 100\n    }),\n    GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {},\n    sigmund = require(\"sigmund\");\n  var path = require(\"path\")\n    // any single thing other than /\n    // don't need to escape / when using new RegExp()\n    ,\n    qmark = \"[^/]\"\n\n    // * => any number of characters\n    ,\n    star = qmark + \"*?\"\n\n    // ** when dots are allowed.  Anything goes, except .. and .\n    // not (^ or / followed by one or two dots followed by $ or /),\n    // followed by anything, any number of times.\n    ,\n    twoStarDot = \"(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?\"\n\n    // not a ^ or / followed by a dot,\n    // followed by anything, any number of times.\n    ,\n    twoStarNoDot = \"(?:(?!(?:\\\\\\/|^)\\\\.).)*?\"\n\n    // characters that need to be escaped in RegExp.\n    ,\n    reSpecials = charSet(\"().*{}+?[]^$\\\\!\");\n\n  // \"abc\" -> { a:true, b:true, c:true }\n  function charSet(s) {\n    return s.split(\"\").reduce(function (set, c) {\n      set[c] = true;\n      return set;\n    }, {});\n  }\n\n  // normalizes slashes.\n  var slashSplit = /\\/+/;\n  minimatch.filter = filter;\n  function filter(pattern, options) {\n    options = options || {};\n    return function (p, i, list) {\n      return minimatch(p, pattern, options);\n    };\n  }\n  function ext(a, b) {\n    a = a || {};\n    b = b || {};\n    var t = {};\n    Object.keys(b).forEach(function (k) {\n      t[k] = b[k];\n    });\n    Object.keys(a).forEach(function (k) {\n      t[k] = a[k];\n    });\n    return t;\n  }\n  minimatch.defaults = function (def) {\n    if (!def || !Object.keys(def).length) return minimatch;\n    var orig = minimatch;\n    var m = function minimatch(p, pattern, options) {\n      return orig.minimatch(p, pattern, ext(def, options));\n    };\n    m.Minimatch = function Minimatch(pattern, options) {\n      return new orig.Minimatch(pattern, ext(def, options));\n    };\n    return m;\n  };\n  Minimatch.defaults = function (def) {\n    if (!def || !Object.keys(def).length) return Minimatch;\n    return minimatch.defaults(def).Minimatch;\n  };\n  function minimatch(p, pattern, options) {\n    if (typeof pattern !== \"string\") {\n      throw new TypeError(\"glob pattern string required\");\n    }\n    if (!options) options = {};\n\n    // shortcut: comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === \"#\") {\n      return false;\n    }\n\n    // \"\" only matches \"\"\n    if (pattern.trim() === \"\") return p === \"\";\n    return new Minimatch(pattern, options).match(p);\n  }\n  function Minimatch(pattern, options) {\n    if (!(this instanceof Minimatch)) {\n      return new Minimatch(pattern, options, cache);\n    }\n    if (typeof pattern !== \"string\") {\n      throw new TypeError(\"glob pattern string required\");\n    }\n    if (!options) options = {};\n    pattern = pattern.trim();\n\n    // windows: need to use /, not \\\n    // On other platforms, \\ is a valid (albeit bad) filename char.\n    if (platform === \"win32\") {\n      pattern = pattern.split(\"\\\\\").join(\"/\");\n    }\n\n    // lru storage.\n    // these things aren't particularly big, but walking down the string\n    // and turning it into a regexp can get pretty costly.\n    var cacheKey = pattern + \"\\n\" + sigmund(options);\n    var cached = minimatch.cache.get(cacheKey);\n    if (cached) return cached;\n    minimatch.cache.set(cacheKey, this);\n    this.options = options;\n    this.set = [];\n    this.pattern = pattern;\n    this.regexp = null;\n    this.negate = false;\n    this.comment = false;\n    this.empty = false;\n\n    // make the set of regexps etc.\n    this.make();\n  }\n  Minimatch.prototype.debug = function () {};\n  Minimatch.prototype.make = make;\n  function make() {\n    // don't do it more than once.\n    if (this._made) return;\n    var pattern = this.pattern;\n    var options = this.options;\n\n    // empty patterns and comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === \"#\") {\n      this.comment = true;\n      return;\n    }\n    if (!pattern) {\n      this.empty = true;\n      return;\n    }\n\n    // step 1: figure out negation, etc.\n    this.parseNegate();\n\n    // step 2: expand braces\n    var set = this.globSet = this.braceExpand();\n    if (options.debug) this.debug = console.error;\n    this.debug(this.pattern, set);\n\n    // step 3: now we have a set, so turn each one into a series of path-portion\n    // matching patterns.\n    // These will be regexps, except in the case of \"**\", which is\n    // set to the GLOBSTAR object for globstar behavior,\n    // and will not contain any / characters\n    set = this.globParts = set.map(function (s) {\n      return s.split(slashSplit);\n    });\n    this.debug(this.pattern, set);\n\n    // glob --> regexps\n    set = set.map(function (s, si, set) {\n      return s.map(this.parse, this);\n    }, this);\n    this.debug(this.pattern, set);\n\n    // filter out everything that didn't compile properly.\n    set = set.filter(function (s) {\n      return -1 === s.indexOf(false);\n    });\n    this.debug(this.pattern, set);\n    this.set = set;\n  }\n  Minimatch.prototype.parseNegate = parseNegate;\n  function parseNegate() {\n    var pattern = this.pattern,\n      negate = false,\n      options = this.options,\n      negateOffset = 0;\n    if (options.nonegate) return;\n    for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === \"!\"; i++) {\n      negate = !negate;\n      negateOffset++;\n    }\n    if (negateOffset) this.pattern = pattern.substr(negateOffset);\n    this.negate = negate;\n  }\n\n  // Brace expansion:\n  // a{b,c}d -> abd acd\n  // a{b,}c -> abc ac\n  // a{0..3}d -> a0d a1d a2d a3d\n  // a{b,c{d,e}f}g -> abg acdfg acefg\n  // a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n  //\n  // Invalid sets are not expanded.\n  // a{2..}b -> a{2..}b\n  // a{b}c -> a{b}c\n  minimatch.braceExpand = function (pattern, options) {\n    return new Minimatch(pattern, options).braceExpand();\n  };\n  Minimatch.prototype.braceExpand = braceExpand;\n  function braceExpand(pattern, options) {\n    options = options || this.options;\n    pattern = typeof pattern === \"undefined\" ? this.pattern : pattern;\n    if (typeof pattern === \"undefined\") {\n      throw new Error(\"undefined pattern\");\n    }\n    if (options.nobrace || !pattern.match(/\\{.*\\}/)) {\n      // shortcut. no need to expand.\n      return [pattern];\n    }\n    var escaping = false;\n\n    // examples and comments refer to this crazy pattern:\n    // a{b,c{d,e},{f,g}h}x{y,z}\n    // expected:\n    // abxy\n    // abxz\n    // acdxy\n    // acdxz\n    // acexy\n    // acexz\n    // afhxy\n    // afhxz\n    // aghxy\n    // aghxz\n\n    // everything before the first \\{ is just a prefix.\n    // So, we pluck that off, and work with the rest,\n    // and then prepend it to everything we find.\n    if (pattern.charAt(0) !== \"{\") {\n      this.debug(pattern);\n      var prefix = null;\n      for (var i = 0, l = pattern.length; i < l; i++) {\n        var c = pattern.charAt(i);\n        this.debug(i, c);\n        if (c === \"\\\\\") {\n          escaping = !escaping;\n        } else if (c === \"{\" && !escaping) {\n          prefix = pattern.substr(0, i);\n          break;\n        }\n      }\n\n      // actually no sets, all { were escaped.\n      if (prefix === null) {\n        this.debug(\"no sets\");\n        return [pattern];\n      }\n      var tail = braceExpand.call(this, pattern.substr(i), options);\n      return tail.map(function (t) {\n        return prefix + t;\n      });\n    }\n\n    // now we have something like:\n    // {b,c{d,e},{f,g}h}x{y,z}\n    // walk through the set, expanding each part, until\n    // the set ends.  then, we'll expand the suffix.\n    // If the set only has a single member, then'll put the {} back\n\n    // first, handle numeric sets, since they're easier\n    var numset = pattern.match(/^\\{(-?[0-9]+)\\.\\.(-?[0-9]+)\\}/);\n    if (numset) {\n      this.debug(\"numset\", numset[1], numset[2]);\n      var suf = braceExpand.call(this, pattern.substr(numset[0].length), options),\n        start = +numset[1],\n        end = +numset[2],\n        inc = start > end ? -1 : 1,\n        set = [];\n      for (var i = start; i != end + inc; i += inc) {\n        // append all the suffixes\n        for (var ii = 0, ll = suf.length; ii < ll; ii++) {\n          set.push(i + suf[ii]);\n        }\n      }\n      return set;\n    }\n\n    // ok, walk through the set\n    // We hope, somewhat optimistically, that there\n    // will be a } at the end.\n    // If the closing brace isn't found, then the pattern is\n    // interpreted as braceExpand(\"\\\\\" + pattern) so that\n    // the leading \\{ will be interpreted literally.\n    var i = 1 // skip the \\{\n      ,\n      depth = 1,\n      set = [],\n      member = \"\",\n      sawEnd = false,\n      escaping = false;\n    function addMember() {\n      set.push(member);\n      member = \"\";\n    }\n    this.debug(\"Entering for\");\n    FOR: for (i = 1, l = pattern.length; i < l; i++) {\n      var c = pattern.charAt(i);\n      this.debug(\"\", i, c);\n      if (escaping) {\n        escaping = false;\n        member += \"\\\\\" + c;\n      } else {\n        switch (c) {\n          case \"\\\\\":\n            escaping = true;\n            continue;\n          case \"{\":\n            depth++;\n            member += \"{\";\n            continue;\n          case \"}\":\n            depth--;\n            // if this closes the actual set, then we're done\n            if (depth === 0) {\n              addMember();\n              // pluck off the close-brace\n              i++;\n              break FOR;\n            } else {\n              member += c;\n              continue;\n            }\n          case \",\":\n            if (depth === 1) {\n              addMember();\n            } else {\n              member += c;\n            }\n            continue;\n          default:\n            member += c;\n            continue;\n        } // switch\n      } // else\n    } // for\n\n    // now we've either finished the set, and the suffix is\n    // pattern.substr(i), or we have *not* closed the set,\n    // and need to escape the leading brace\n    if (depth !== 0) {\n      this.debug(\"didn't close\", pattern);\n      return braceExpand.call(this, \"\\\\\" + pattern, options);\n    }\n\n    // x{y,z} -> [\"xy\", \"xz\"]\n    this.debug(\"set\", set);\n    this.debug(\"suffix\", pattern.substr(i));\n    var suf = braceExpand.call(this, pattern.substr(i), options);\n    // [\"b\", \"c{d,e}\",\"{f,g}h\"] ->\n    //   [[\"b\"], [\"cd\", \"ce\"], [\"fh\", \"gh\"]]\n    var addBraces = set.length === 1;\n    this.debug(\"set pre-expanded\", set);\n    set = set.map(function (p) {\n      return braceExpand.call(this, p, options);\n    }, this);\n    this.debug(\"set expanded\", set);\n\n    // [[\"b\"], [\"cd\", \"ce\"], [\"fh\", \"gh\"]] ->\n    //   [\"b\", \"cd\", \"ce\", \"fh\", \"gh\"]\n    set = set.reduce(function (l, r) {\n      return l.concat(r);\n    });\n    if (addBraces) {\n      set = set.map(function (s) {\n        return \"{\" + s + \"}\";\n      });\n    }\n\n    // now attach the suffixes.\n    var ret = [];\n    for (var i = 0, l = set.length; i < l; i++) {\n      for (var ii = 0, ll = suf.length; ii < ll; ii++) {\n        ret.push(set[i] + suf[ii]);\n      }\n    }\n    return ret;\n  }\n\n  // parse a component of the expanded set.\n  // At this point, no pattern may contain \"/\" in it\n  // so we're going to return a 2d array, where each entry is the full\n  // pattern, split on '/', and then turned into a regular expression.\n  // A regexp is made at the end which joins each array with an\n  // escaped /, and another full one which joins each regexp with |.\n  //\n  // Following the lead of Bash 4.1, note that \"**\" only has special meaning\n  // when it is the *only* thing in a path portion.  Otherwise, any series\n  // of * is equivalent to a single *.  Globstar behavior is enabled by\n  // default, and can be disabled by setting options.noglobstar.\n  Minimatch.prototype.parse = parse;\n  var SUBPARSE = {};\n  function parse(pattern, isSub) {\n    var options = this.options;\n\n    // shortcuts\n    if (!options.noglobstar && pattern === \"**\") return GLOBSTAR;\n    if (pattern === \"\") return \"\";\n    var re = \"\",\n      hasMagic = !!options.nocase,\n      escaping = false\n      // ? => one single character\n      ,\n      patternListStack = [],\n      plType,\n      stateChar,\n      inClass = false,\n      reClassStart = -1,\n      classStart = -1\n      // . and .. never match anything that doesn't start with .,\n      // even when options.dot is set.\n      ,\n      patternStart = pattern.charAt(0) === \".\" ? \"\" // anything\n      // not (start or / followed by . or .. followed by / or end)\n      : options.dot ? \"(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))\" : \"(?!\\\\.)\",\n      self = this;\n    function clearStateChar() {\n      if (stateChar) {\n        // we had some state-tracking character\n        // that wasn't consumed by this pass.\n        switch (stateChar) {\n          case \"*\":\n            re += star;\n            hasMagic = true;\n            break;\n          case \"?\":\n            re += qmark;\n            hasMagic = true;\n            break;\n          default:\n            re += \"\\\\\" + stateChar;\n            break;\n        }\n        self.debug('clearStateChar %j %j', stateChar, re);\n        stateChar = false;\n      }\n    }\n    for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {\n      this.debug(\"%s\\t%s %s %j\", pattern, i, re, c);\n\n      // skip over any that are escaped.\n      if (escaping && reSpecials[c]) {\n        re += \"\\\\\" + c;\n        escaping = false;\n        continue;\n      }\n      SWITCH: switch (c) {\n        case \"/\":\n          // completely not allowed, even escaped.\n          // Should already be path-split by now.\n          return false;\n        case \"\\\\\":\n          clearStateChar();\n          escaping = true;\n          continue;\n\n        // the various stateChar values\n        // for the \"extglob\" stuff.\n        case \"?\":\n        case \"*\":\n        case \"+\":\n        case \"@\":\n        case \"!\":\n          this.debug(\"%s\\t%s %s %j <-- stateChar\", pattern, i, re, c);\n\n          // all of those are literals inside a class, except that\n          // the glob [!a] means [^a] in regexp\n          if (inClass) {\n            this.debug('  in class');\n            if (c === \"!\" && i === classStart + 1) c = \"^\";\n            re += c;\n            continue;\n          }\n\n          // if we already have a stateChar, then it means\n          // that there was something like ** or +? in there.\n          // Handle the stateChar, then proceed with this one.\n          self.debug('call clearStateChar %j', stateChar);\n          clearStateChar();\n          stateChar = c;\n          // if extglob is disabled, then +(asdf|foo) isn't a thing.\n          // just clear the statechar *now*, rather than even diving into\n          // the patternList stuff.\n          if (options.noext) clearStateChar();\n          continue;\n        case \"(\":\n          if (inClass) {\n            re += \"(\";\n            continue;\n          }\n          if (!stateChar) {\n            re += \"\\\\(\";\n            continue;\n          }\n          plType = stateChar;\n          patternListStack.push({\n            type: plType,\n            start: i - 1,\n            reStart: re.length\n          });\n          // negation is (?:(?!js)[^/]*)\n          re += stateChar === \"!\" ? \"(?:(?!\" : \"(?:\";\n          this.debug('plType %j %j', stateChar, re);\n          stateChar = false;\n          continue;\n        case \")\":\n          if (inClass || !patternListStack.length) {\n            re += \"\\\\)\";\n            continue;\n          }\n          clearStateChar();\n          hasMagic = true;\n          re += \")\";\n          plType = patternListStack.pop().type;\n          // negation is (?:(?!js)[^/]*)\n          // The others are (?:<pattern>)<type>\n          switch (plType) {\n            case \"!\":\n              re += \"[^/]*?)\";\n              break;\n            case \"?\":\n            case \"+\":\n            case \"*\":\n              re += plType;\n            case \"@\":\n              break;\n            // the default anyway\n          }\n\n          continue;\n        case \"|\":\n          if (inClass || !patternListStack.length || escaping) {\n            re += \"\\\\|\";\n            escaping = false;\n            continue;\n          }\n          clearStateChar();\n          re += \"|\";\n          continue;\n\n        // these are mostly the same in regexp and glob\n        case \"[\":\n          // swallow any state-tracking char before the [\n          clearStateChar();\n          if (inClass) {\n            re += \"\\\\\" + c;\n            continue;\n          }\n          inClass = true;\n          classStart = i;\n          reClassStart = re.length;\n          re += c;\n          continue;\n        case \"]\":\n          //  a right bracket shall lose its special\n          //  meaning and represent itself in\n          //  a bracket expression if it occurs\n          //  first in the list.  -- POSIX.2 2.8.3.2\n          if (i === classStart + 1 || !inClass) {\n            re += \"\\\\\" + c;\n            escaping = false;\n            continue;\n          }\n\n          // finish up the class.\n          hasMagic = true;\n          inClass = false;\n          re += c;\n          continue;\n        default:\n          // swallow any state char that wasn't consumed\n          clearStateChar();\n          if (escaping) {\n            // no need\n            escaping = false;\n          } else if (reSpecials[c] && !(c === \"^\" && inClass)) {\n            re += \"\\\\\";\n          }\n          re += c;\n      } // switch\n    } // for\n\n    // handle the case where we left a class open.\n    // \"[abc\" is valid, equivalent to \"\\[abc\"\n    if (inClass) {\n      // split where the last [ was, and escape it\n      // this is a huge pita.  We now have to re-walk\n      // the contents of the would-be class to re-translate\n      // any characters that were passed through as-is\n      var cs = pattern.substr(classStart + 1),\n        sp = this.parse(cs, SUBPARSE);\n      re = re.substr(0, reClassStart) + \"\\\\[\" + sp[0];\n      hasMagic = hasMagic || sp[1];\n    }\n\n    // handle the case where we had a +( thing at the *end*\n    // of the pattern.\n    // each pattern list stack adds 3 chars, and we need to go through\n    // and escape any | chars that were passed through as-is for the regexp.\n    // Go through and escape them, taking care not to double-escape any\n    // | chars that were already escaped.\n    var pl;\n    while (pl = patternListStack.pop()) {\n      var tail = re.slice(pl.reStart + 3);\n      // maybe some even number of \\, then maybe 1 \\, followed by a |\n      tail = tail.replace(/((?:\\\\{2})*)(\\\\?)\\|/g, function (_, $1, $2) {\n        if (!$2) {\n          // the | isn't already escaped, so escape it.\n          $2 = \"\\\\\";\n        }\n\n        // need to escape all those slashes *again*, without escaping the\n        // one that we need for escaping the | character.  As it works out,\n        // escaping an even number of slashes can be done by simply repeating\n        // it exactly after itself.  That's why this trick works.\n        //\n        // I am sorry that you have to see this.\n        return $1 + $1 + $2 + \"|\";\n      });\n      this.debug(\"tail=%j\\n   %s\", tail, tail);\n      var t = pl.type === \"*\" ? star : pl.type === \"?\" ? qmark : \"\\\\\" + pl.type;\n      hasMagic = true;\n      re = re.slice(0, pl.reStart) + t + \"\\\\(\" + tail;\n    }\n\n    // handle trailing things that only matter at the very end.\n    clearStateChar();\n    if (escaping) {\n      // trailing \\\\\n      re += \"\\\\\\\\\";\n    }\n\n    // only need to apply the nodot start if the re starts with\n    // something that could conceivably capture a dot\n    var addPatternStart = false;\n    switch (re.charAt(0)) {\n      case \".\":\n      case \"[\":\n      case \"(\":\n        addPatternStart = true;\n    }\n\n    // if the re is not \"\" at this point, then we need to make sure\n    // it doesn't match against an empty path part.\n    // Otherwise a/* will match a/, which it should not.\n    if (re !== \"\" && hasMagic) re = \"(?=.)\" + re;\n    if (addPatternStart) re = patternStart + re;\n\n    // parsing just a piece of a larger pattern.\n    if (isSub === SUBPARSE) {\n      return [re, hasMagic];\n    }\n\n    // skip the regexp for non-magical patterns\n    // unescape anything in it, though, so that it'll be\n    // an exact match against a file etc.\n    if (!hasMagic) {\n      return globUnescape(pattern);\n    }\n    var flags = options.nocase ? \"i\" : \"\",\n      regExp = new RegExp(\"^\" + re + \"$\", flags);\n    regExp._glob = pattern;\n    regExp._src = re;\n    return regExp;\n  }\n  minimatch.makeRe = function (pattern, options) {\n    return new Minimatch(pattern, options || {}).makeRe();\n  };\n  Minimatch.prototype.makeRe = makeRe;\n  function makeRe() {\n    if (this.regexp || this.regexp === false) return this.regexp;\n\n    // at this point, this.set is a 2d array of partial\n    // pattern strings, or \"**\".\n    //\n    // It's better to use .match().  This function shouldn't\n    // be used, really, but it's pretty convenient sometimes,\n    // when you just want to work with a regex.\n    var set = this.set;\n    if (!set.length) return this.regexp = false;\n    var options = this.options;\n    var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot,\n      flags = options.nocase ? \"i\" : \"\";\n    var re = set.map(function (pattern) {\n      return pattern.map(function (p) {\n        return p === GLOBSTAR ? twoStar : typeof p === \"string\" ? regExpEscape(p) : p._src;\n      }).join(\"\\\\\\/\");\n    }).join(\"|\");\n\n    // must match entire pattern\n    // ending in a * or ** will make it less strict.\n    re = \"^(?:\" + re + \")$\";\n\n    // can match anything, as long as it's not this.\n    if (this.negate) re = \"^(?!\" + re + \").*$\";\n    try {\n      return this.regexp = new RegExp(re, flags);\n    } catch (ex) {\n      return this.regexp = false;\n    }\n  }\n  minimatch.match = function (list, pattern, options) {\n    var mm = new Minimatch(pattern, options);\n    list = list.filter(function (f) {\n      return mm.match(f);\n    });\n    if (options.nonull && !list.length) {\n      list.push(pattern);\n    }\n    return list;\n  };\n  Minimatch.prototype.match = match;\n  function match(f, partial) {\n    this.debug(\"match\", f, this.pattern);\n    // short-circuit in the case of busted things.\n    // comments, etc.\n    if (this.comment) return false;\n    if (this.empty) return f === \"\";\n    if (f === \"/\" && partial) return true;\n    var options = this.options;\n\n    // windows: need to use /, not \\\n    // On other platforms, \\ is a valid (albeit bad) filename char.\n    if (platform === \"win32\") {\n      f = f.split(\"\\\\\").join(\"/\");\n    }\n\n    // treat the test path as a set of pathparts.\n    f = f.split(slashSplit);\n    this.debug(this.pattern, \"split\", f);\n\n    // just ONE of the pattern sets in this.set needs to match\n    // in order for it to be valid.  If negating, then just one\n    // match means that we have failed.\n    // Either way, return on the first hit.\n\n    var set = this.set;\n    this.debug(this.pattern, \"set\", set);\n    var splitFile = path.basename(f.join(\"/\")).split(\"/\");\n    for (var i = 0, l = set.length; i < l; i++) {\n      var pattern = set[i],\n        file = f;\n      if (options.matchBase && pattern.length === 1) {\n        file = splitFile;\n      }\n      var hit = this.matchOne(file, pattern, partial);\n      if (hit) {\n        if (options.flipNegate) return true;\n        return !this.negate;\n      }\n    }\n\n    // didn't get any hits.  this is success if it's a negative\n    // pattern, failure otherwise.\n    if (options.flipNegate) return false;\n    return this.negate;\n  }\n\n  // set partial to true to test if, for example,\n  // \"/a/b\" matches the start of \"/*/b/*/d\"\n  // Partial means, if you run out of file before you run\n  // out of pattern, then that's fine, as long as all\n  // the parts match.\n  Minimatch.prototype.matchOne = function (file, pattern, partial) {\n    var options = this.options;\n    this.debug(\"matchOne\", {\n      \"this\": this,\n      file: file,\n      pattern: pattern\n    });\n    this.debug(\"matchOne\", file.length, pattern.length);\n    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {\n      this.debug(\"matchOne loop\");\n      var p = pattern[pi],\n        f = file[fi];\n      this.debug(pattern, p, f);\n\n      // should be impossible.\n      // some invalid regexp stuff in the set.\n      if (p === false) return false;\n      if (p === GLOBSTAR) {\n        this.debug('GLOBSTAR', [pattern, p, f]);\n\n        // \"**\"\n        // a/**/b/**/c would match the following:\n        // a/b/x/y/z/c\n        // a/x/y/z/b/c\n        // a/b/x/b/x/c\n        // a/b/c\n        // To do this, take the rest of the pattern after\n        // the **, and see if it would match the file remainder.\n        // If so, return success.\n        // If not, the ** \"swallows\" a segment, and try again.\n        // This is recursively awful.\n        //\n        // a/**/b/**/c matching a/b/x/y/z/c\n        // - a matches a\n        // - doublestar\n        //   - matchOne(b/x/y/z/c, b/**/c)\n        //     - b matches b\n        //     - doublestar\n        //       - matchOne(x/y/z/c, c) -> no\n        //       - matchOne(y/z/c, c) -> no\n        //       - matchOne(z/c, c) -> no\n        //       - matchOne(c, c) yes, hit\n        var fr = fi,\n          pr = pi + 1;\n        if (pr === pl) {\n          this.debug('** at the end');\n          // a ** at the end will just swallow the rest.\n          // We have found a match.\n          // however, it will not swallow /.x, unless\n          // options.dot is set.\n          // . and .. are *never* matched by **, for explosively\n          // exponential reasons.\n          for (; fi < fl; fi++) {\n            if (file[fi] === \".\" || file[fi] === \"..\" || !options.dot && file[fi].charAt(0) === \".\") return false;\n          }\n          return true;\n        }\n\n        // ok, let's see if we can swallow whatever we can.\n        WHILE: while (fr < fl) {\n          var swallowee = file[fr];\n          this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee);\n\n          // XXX remove this slice.  Just pass the start index.\n          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n            this.debug('globstar found match!', fr, fl, swallowee);\n            // found a match.\n            return true;\n          } else {\n            // can't swallow \".\" or \"..\" ever.\n            // can only swallow \".foo\" when explicitly asked.\n            if (swallowee === \".\" || swallowee === \"..\" || !options.dot && swallowee.charAt(0) === \".\") {\n              this.debug(\"dot detected!\", file, fr, pattern, pr);\n              break WHILE;\n            }\n\n            // ** swallows a segment, and continue.\n            this.debug('globstar swallow a segment, and continue');\n            fr++;\n          }\n        }\n        // no match was found.\n        // However, in partial mode, we can't say this is necessarily over.\n        // If there's more *pattern* left, then \n        if (partial) {\n          // ran out of file\n          this.debug(\"\\n>>> no match, partial?\", file, fr, pattern, pr);\n          if (fr === fl) return true;\n        }\n        return false;\n      }\n\n      // something other than **\n      // non-magic patterns just have to match exactly\n      // patterns with magic have been turned into regexps.\n      var hit;\n      if (typeof p === \"string\") {\n        if (options.nocase) {\n          hit = f.toLowerCase() === p.toLowerCase();\n        } else {\n          hit = f === p;\n        }\n        this.debug(\"string match\", p, f, hit);\n      } else {\n        hit = f.match(p);\n        this.debug(\"pattern match\", p, f, hit);\n      }\n      if (!hit) return false;\n    }\n\n    // Note: ending in / means that we'll get a final \"\"\n    // at the end of the pattern.  This can only match a\n    // corresponding \"\" at the end of the file.\n    // If the file ends in /, then it can only match a\n    // a pattern that ends in /, unless the pattern just\n    // doesn't have any more for it. But, a/b/ should *not*\n    // match \"a/b/*\", even though \"\" matches against the\n    // [^/]*? pattern, except in partial mode, where it might\n    // simply not be reached yet.\n    // However, a/b/ should still satisfy a/*\n\n    // now either we fell off the end of the pattern, or we're done.\n    if (fi === fl && pi === pl) {\n      // ran out of pattern and filename at the same time.\n      // an exact hit!\n      return true;\n    } else if (fi === fl) {\n      // ran out of file, but still had pattern left.\n      // this is ok if we're doing the match as part of\n      // a glob fs traversal.\n      return partial;\n    } else if (pi === pl) {\n      // ran out of pattern, still have file left.\n      // this is only acceptable if we're on the very last\n      // empty segment of a file with a trailing slash.\n      // a/* should match a/b/\n      var emptyFileEnd = fi === fl - 1 && file[fi] === \"\";\n      return emptyFileEnd;\n    }\n\n    // should be unreachable.\n    throw new Error(\"wtf?\");\n  };\n\n  // replace stuff like \\* with *\n  function globUnescape(s) {\n    return s.replace(/\\\\(.)/g, \"$1\");\n  }\n  function regExpEscape(s) {\n    return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\n  }\n})(typeof require === \"function\" ? require : null, this, typeof module === \"object\" ? module : null, typeof process === \"object\" ? process.platform : \"win32\");","map":{"version":3,"names":["require","exports","module","platform","minimatch","id","sigmund","obj","JSON","stringify","basename","f","split","e","pop","LRUCache","cache","cnt","set","k","v","get","Minimatch","LRU","max","GLOBSTAR","path","qmark","star","twoStarDot","twoStarNoDot","reSpecials","charSet","s","reduce","c","slashSplit","filter","pattern","options","p","i","list","ext","a","b","t","Object","keys","forEach","defaults","def","length","orig","m","TypeError","nocomment","charAt","trim","match","join","cacheKey","cached","regexp","negate","comment","empty","make","prototype","debug","_made","parseNegate","globSet","braceExpand","console","error","globParts","map","si","parse","indexOf","negateOffset","nonegate","l","substr","Error","nobrace","escaping","prefix","tail","call","numset","suf","start","end","inc","ii","ll","push","depth","member","sawEnd","addMember","FOR","addBraces","r","concat","ret","SUBPARSE","isSub","noglobstar","re","hasMagic","nocase","patternListStack","plType","stateChar","inClass","reClassStart","classStart","patternStart","dot","self","clearStateChar","len","SWITCH","noext","type","reStart","cs","sp","pl","slice","replace","_","$1","$2","addPatternStart","globUnescape","flags","regExp","RegExp","_glob","_src","makeRe","twoStar","regExpEscape","ex","mm","nonull","partial","splitFile","file","matchBase","hit","matchOne","flipNegate","fi","pi","fl","fr","pr","WHILE","swallowee","toLowerCase","emptyFileEnd","process"],"sources":["C:/Users/twotr/Desktop/College/vsCode/WorkHumanApplication/country-search/node_modules/scatter/node_modules/minimatch/minimatch.js"],"sourcesContent":[";(function (require, exports, module, platform) {\n\nif (module) module.exports = minimatch\nelse exports.minimatch = minimatch\n\nif (!require) {\n  require = function (id) {\n    switch (id) {\n      case \"sigmund\": return function sigmund (obj) {\n        return JSON.stringify(obj)\n      }\n      case \"path\": return { basename: function (f) {\n        f = f.split(/[\\/\\\\]/)\n        var e = f.pop()\n        if (!e) e = f.pop()\n        return e\n      }}\n      case \"lru-cache\": return function LRUCache () {\n        // not quite an LRU, but still space-limited.\n        var cache = {}\n        var cnt = 0\n        this.set = function (k, v) {\n          cnt ++\n          if (cnt >= 100) cache = {}\n          cache[k] = v\n        }\n        this.get = function (k) { return cache[k] }\n      }\n    }\n  }\n}\n\nminimatch.Minimatch = Minimatch\n\nvar LRU = require(\"lru-cache\")\n  , cache = minimatch.cache = new LRU({max: 100})\n  , GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}\n  , sigmund = require(\"sigmund\")\n\nvar path = require(\"path\")\n  // any single thing other than /\n  // don't need to escape / when using new RegExp()\n  , qmark = \"[^/]\"\n\n  // * => any number of characters\n  , star = qmark + \"*?\"\n\n  // ** when dots are allowed.  Anything goes, except .. and .\n  // not (^ or / followed by one or two dots followed by $ or /),\n  // followed by anything, any number of times.\n  , twoStarDot = \"(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?\"\n\n  // not a ^ or / followed by a dot,\n  // followed by anything, any number of times.\n  , twoStarNoDot = \"(?:(?!(?:\\\\\\/|^)\\\\.).)*?\"\n\n  // characters that need to be escaped in RegExp.\n  , reSpecials = charSet(\"().*{}+?[]^$\\\\!\")\n\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet (s) {\n  return s.split(\"\").reduce(function (set, c) {\n    set[c] = true\n    return set\n  }, {})\n}\n\n// normalizes slashes.\nvar slashSplit = /\\/+/\n\nminimatch.filter = filter\nfunction filter (pattern, options) {\n  options = options || {}\n  return function (p, i, list) {\n    return minimatch(p, pattern, options)\n  }\n}\n\nfunction ext (a, b) {\n  a = a || {}\n  b = b || {}\n  var t = {}\n  Object.keys(b).forEach(function (k) {\n    t[k] = b[k]\n  })\n  Object.keys(a).forEach(function (k) {\n    t[k] = a[k]\n  })\n  return t\n}\n\nminimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return minimatch\n\n  var orig = minimatch\n\n  var m = function minimatch (p, pattern, options) {\n    return orig.minimatch(p, pattern, ext(def, options))\n  }\n\n  m.Minimatch = function Minimatch (pattern, options) {\n    return new orig.Minimatch(pattern, ext(def, options))\n  }\n\n  return m\n}\n\nMinimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return Minimatch\n  return minimatch.defaults(def).Minimatch\n}\n\n\nfunction minimatch (p, pattern, options) {\n  if (typeof pattern !== \"string\") {\n    throw new TypeError(\"glob pattern string required\")\n  }\n\n  if (!options) options = {}\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === \"#\") {\n    return false\n  }\n\n  // \"\" only matches \"\"\n  if (pattern.trim() === \"\") return p === \"\"\n\n  return new Minimatch(pattern, options).match(p)\n}\n\nfunction Minimatch (pattern, options) {\n  if (!(this instanceof Minimatch)) {\n    return new Minimatch(pattern, options, cache)\n  }\n\n  if (typeof pattern !== \"string\") {\n    throw new TypeError(\"glob pattern string required\")\n  }\n\n  if (!options) options = {}\n  pattern = pattern.trim()\n\n  // windows: need to use /, not \\\n  // On other platforms, \\ is a valid (albeit bad) filename char.\n  if (platform === \"win32\") {\n    pattern = pattern.split(\"\\\\\").join(\"/\")\n  }\n\n  // lru storage.\n  // these things aren't particularly big, but walking down the string\n  // and turning it into a regexp can get pretty costly.\n  var cacheKey = pattern + \"\\n\" + sigmund(options)\n  var cached = minimatch.cache.get(cacheKey)\n  if (cached) return cached\n  minimatch.cache.set(cacheKey, this)\n\n  this.options = options\n  this.set = []\n  this.pattern = pattern\n  this.regexp = null\n  this.negate = false\n  this.comment = false\n  this.empty = false\n\n  // make the set of regexps etc.\n  this.make()\n}\n\nMinimatch.prototype.debug = function() {}\n\nMinimatch.prototype.make = make\nfunction make () {\n  // don't do it more than once.\n  if (this._made) return\n\n  var pattern = this.pattern\n  var options = this.options\n\n  // empty patterns and comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === \"#\") {\n    this.comment = true\n    return\n  }\n  if (!pattern) {\n    this.empty = true\n    return\n  }\n\n  // step 1: figure out negation, etc.\n  this.parseNegate()\n\n  // step 2: expand braces\n  var set = this.globSet = this.braceExpand()\n\n  if (options.debug) this.debug = console.error\n\n  this.debug(this.pattern, set)\n\n  // step 3: now we have a set, so turn each one into a series of path-portion\n  // matching patterns.\n  // These will be regexps, except in the case of \"**\", which is\n  // set to the GLOBSTAR object for globstar behavior,\n  // and will not contain any / characters\n  set = this.globParts = set.map(function (s) {\n    return s.split(slashSplit)\n  })\n\n  this.debug(this.pattern, set)\n\n  // glob --> regexps\n  set = set.map(function (s, si, set) {\n    return s.map(this.parse, this)\n  }, this)\n\n  this.debug(this.pattern, set)\n\n  // filter out everything that didn't compile properly.\n  set = set.filter(function (s) {\n    return -1 === s.indexOf(false)\n  })\n\n  this.debug(this.pattern, set)\n\n  this.set = set\n}\n\nMinimatch.prototype.parseNegate = parseNegate\nfunction parseNegate () {\n  var pattern = this.pattern\n    , negate = false\n    , options = this.options\n    , negateOffset = 0\n\n  if (options.nonegate) return\n\n  for ( var i = 0, l = pattern.length\n      ; i < l && pattern.charAt(i) === \"!\"\n      ; i ++) {\n    negate = !negate\n    negateOffset ++\n  }\n\n  if (negateOffset) this.pattern = pattern.substr(negateOffset)\n  this.negate = negate\n}\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function (pattern, options) {\n  return new Minimatch(pattern, options).braceExpand()\n}\n\nMinimatch.prototype.braceExpand = braceExpand\nfunction braceExpand (pattern, options) {\n  options = options || this.options\n  pattern = typeof pattern === \"undefined\"\n    ? this.pattern : pattern\n\n  if (typeof pattern === \"undefined\") {\n    throw new Error(\"undefined pattern\")\n  }\n\n  if (options.nobrace ||\n      !pattern.match(/\\{.*\\}/)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  var escaping = false\n\n  // examples and comments refer to this crazy pattern:\n  // a{b,c{d,e},{f,g}h}x{y,z}\n  // expected:\n  // abxy\n  // abxz\n  // acdxy\n  // acdxz\n  // acexy\n  // acexz\n  // afhxy\n  // afhxz\n  // aghxy\n  // aghxz\n\n  // everything before the first \\{ is just a prefix.\n  // So, we pluck that off, and work with the rest,\n  // and then prepend it to everything we find.\n  if (pattern.charAt(0) !== \"{\") {\n    this.debug(pattern)\n    var prefix = null\n    for (var i = 0, l = pattern.length; i < l; i ++) {\n      var c = pattern.charAt(i)\n      this.debug(i, c)\n      if (c === \"\\\\\") {\n        escaping = !escaping\n      } else if (c === \"{\" && !escaping) {\n        prefix = pattern.substr(0, i)\n        break\n      }\n    }\n\n    // actually no sets, all { were escaped.\n    if (prefix === null) {\n      this.debug(\"no sets\")\n      return [pattern]\n    }\n\n   var tail = braceExpand.call(this, pattern.substr(i), options)\n    return tail.map(function (t) {\n      return prefix + t\n    })\n  }\n\n  // now we have something like:\n  // {b,c{d,e},{f,g}h}x{y,z}\n  // walk through the set, expanding each part, until\n  // the set ends.  then, we'll expand the suffix.\n  // If the set only has a single member, then'll put the {} back\n\n  // first, handle numeric sets, since they're easier\n  var numset = pattern.match(/^\\{(-?[0-9]+)\\.\\.(-?[0-9]+)\\}/)\n  if (numset) {\n    this.debug(\"numset\", numset[1], numset[2])\n    var suf = braceExpand.call(this, pattern.substr(numset[0].length), options)\n      , start = +numset[1]\n      , end = +numset[2]\n      , inc = start > end ? -1 : 1\n      , set = []\n    for (var i = start; i != (end + inc); i += inc) {\n      // append all the suffixes\n      for (var ii = 0, ll = suf.length; ii < ll; ii ++) {\n        set.push(i + suf[ii])\n      }\n    }\n    return set\n  }\n\n  // ok, walk through the set\n  // We hope, somewhat optimistically, that there\n  // will be a } at the end.\n  // If the closing brace isn't found, then the pattern is\n  // interpreted as braceExpand(\"\\\\\" + pattern) so that\n  // the leading \\{ will be interpreted literally.\n  var i = 1 // skip the \\{\n    , depth = 1\n    , set = []\n    , member = \"\"\n    , sawEnd = false\n    , escaping = false\n\n  function addMember () {\n    set.push(member)\n    member = \"\"\n  }\n\n  this.debug(\"Entering for\")\n  FOR: for (i = 1, l = pattern.length; i < l; i ++) {\n    var c = pattern.charAt(i)\n    this.debug(\"\", i, c)\n\n    if (escaping) {\n      escaping = false\n      member += \"\\\\\" + c\n    } else {\n      switch (c) {\n        case \"\\\\\":\n          escaping = true\n          continue\n\n        case \"{\":\n          depth ++\n          member += \"{\"\n          continue\n\n        case \"}\":\n          depth --\n          // if this closes the actual set, then we're done\n          if (depth === 0) {\n            addMember()\n            // pluck off the close-brace\n            i ++\n            break FOR\n          } else {\n            member += c\n            continue\n          }\n\n        case \",\":\n          if (depth === 1) {\n            addMember()\n          } else {\n            member += c\n          }\n          continue\n\n        default:\n          member += c\n          continue\n      } // switch\n    } // else\n  } // for\n\n  // now we've either finished the set, and the suffix is\n  // pattern.substr(i), or we have *not* closed the set,\n  // and need to escape the leading brace\n  if (depth !== 0) {\n    this.debug(\"didn't close\", pattern)\n    return braceExpand.call(this, \"\\\\\" + pattern, options)\n  }\n\n  // x{y,z} -> [\"xy\", \"xz\"]\n  this.debug(\"set\", set)\n  this.debug(\"suffix\", pattern.substr(i))\n  var suf = braceExpand.call(this, pattern.substr(i), options)\n  // [\"b\", \"c{d,e}\",\"{f,g}h\"] ->\n  //   [[\"b\"], [\"cd\", \"ce\"], [\"fh\", \"gh\"]]\n  var addBraces = set.length === 1\n  this.debug(\"set pre-expanded\", set)\n  set = set.map(function (p) {\n    return braceExpand.call(this, p, options)\n  }, this)\n  this.debug(\"set expanded\", set)\n\n\n  // [[\"b\"], [\"cd\", \"ce\"], [\"fh\", \"gh\"]] ->\n  //   [\"b\", \"cd\", \"ce\", \"fh\", \"gh\"]\n  set = set.reduce(function (l, r) {\n    return l.concat(r)\n  })\n\n  if (addBraces) {\n    set = set.map(function (s) {\n      return \"{\" + s + \"}\"\n    })\n  }\n\n  // now attach the suffixes.\n  var ret = []\n  for (var i = 0, l = set.length; i < l; i ++) {\n    for (var ii = 0, ll = suf.length; ii < ll; ii ++) {\n      ret.push(set[i] + suf[ii])\n    }\n  }\n  return ret\n}\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse\nvar SUBPARSE = {}\nfunction parse (pattern, isSub) {\n  var options = this.options\n\n  // shortcuts\n  if (!options.noglobstar && pattern === \"**\") return GLOBSTAR\n  if (pattern === \"\") return \"\"\n\n  var re = \"\"\n    , hasMagic = !!options.nocase\n    , escaping = false\n    // ? => one single character\n    , patternListStack = []\n    , plType\n    , stateChar\n    , inClass = false\n    , reClassStart = -1\n    , classStart = -1\n    // . and .. never match anything that doesn't start with .,\n    // even when options.dot is set.\n    , patternStart = pattern.charAt(0) === \".\" ? \"\" // anything\n      // not (start or / followed by . or .. followed by / or end)\n      : options.dot ? \"(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))\"\n      : \"(?!\\\\.)\"\n    , self = this\n\n  function clearStateChar () {\n    if (stateChar) {\n      // we had some state-tracking character\n      // that wasn't consumed by this pass.\n      switch (stateChar) {\n        case \"*\":\n          re += star\n          hasMagic = true\n          break\n        case \"?\":\n          re += qmark\n          hasMagic = true\n          break\n        default:\n          re += \"\\\\\"+stateChar\n          break\n      }\n      self.debug('clearStateChar %j %j', stateChar, re)\n      stateChar = false\n    }\n  }\n\n  for ( var i = 0, len = pattern.length, c\n      ; (i < len) && (c = pattern.charAt(i))\n      ; i ++ ) {\n\n    this.debug(\"%s\\t%s %s %j\", pattern, i, re, c)\n\n    // skip over any that are escaped.\n    if (escaping && reSpecials[c]) {\n      re += \"\\\\\" + c\n      escaping = false\n      continue\n    }\n\n    SWITCH: switch (c) {\n      case \"/\":\n        // completely not allowed, even escaped.\n        // Should already be path-split by now.\n        return false\n\n      case \"\\\\\":\n        clearStateChar()\n        escaping = true\n        continue\n\n      // the various stateChar values\n      // for the \"extglob\" stuff.\n      case \"?\":\n      case \"*\":\n      case \"+\":\n      case \"@\":\n      case \"!\":\n        this.debug(\"%s\\t%s %s %j <-- stateChar\", pattern, i, re, c)\n\n        // all of those are literals inside a class, except that\n        // the glob [!a] means [^a] in regexp\n        if (inClass) {\n          this.debug('  in class')\n          if (c === \"!\" && i === classStart + 1) c = \"^\"\n          re += c\n          continue\n        }\n\n        // if we already have a stateChar, then it means\n        // that there was something like ** or +? in there.\n        // Handle the stateChar, then proceed with this one.\n        self.debug('call clearStateChar %j', stateChar)\n        clearStateChar()\n        stateChar = c\n        // if extglob is disabled, then +(asdf|foo) isn't a thing.\n        // just clear the statechar *now*, rather than even diving into\n        // the patternList stuff.\n        if (options.noext) clearStateChar()\n        continue\n\n      case \"(\":\n        if (inClass) {\n          re += \"(\"\n          continue\n        }\n\n        if (!stateChar) {\n          re += \"\\\\(\"\n          continue\n        }\n\n        plType = stateChar\n        patternListStack.push({ type: plType\n                              , start: i - 1\n                              , reStart: re.length })\n        // negation is (?:(?!js)[^/]*)\n        re += stateChar === \"!\" ? \"(?:(?!\" : \"(?:\"\n        this.debug('plType %j %j', stateChar, re)\n        stateChar = false\n        continue\n\n      case \")\":\n        if (inClass || !patternListStack.length) {\n          re += \"\\\\)\"\n          continue\n        }\n\n        clearStateChar()\n        hasMagic = true\n        re += \")\"\n        plType = patternListStack.pop().type\n        // negation is (?:(?!js)[^/]*)\n        // The others are (?:<pattern>)<type>\n        switch (plType) {\n          case \"!\":\n            re += \"[^/]*?)\"\n            break\n          case \"?\":\n          case \"+\":\n          case \"*\": re += plType\n          case \"@\": break // the default anyway\n        }\n        continue\n\n      case \"|\":\n        if (inClass || !patternListStack.length || escaping) {\n          re += \"\\\\|\"\n          escaping = false\n          continue\n        }\n\n        clearStateChar()\n        re += \"|\"\n        continue\n\n      // these are mostly the same in regexp and glob\n      case \"[\":\n        // swallow any state-tracking char before the [\n        clearStateChar()\n\n        if (inClass) {\n          re += \"\\\\\" + c\n          continue\n        }\n\n        inClass = true\n        classStart = i\n        reClassStart = re.length\n        re += c\n        continue\n\n      case \"]\":\n        //  a right bracket shall lose its special\n        //  meaning and represent itself in\n        //  a bracket expression if it occurs\n        //  first in the list.  -- POSIX.2 2.8.3.2\n        if (i === classStart + 1 || !inClass) {\n          re += \"\\\\\" + c\n          escaping = false\n          continue\n        }\n\n        // finish up the class.\n        hasMagic = true\n        inClass = false\n        re += c\n        continue\n\n      default:\n        // swallow any state char that wasn't consumed\n        clearStateChar()\n\n        if (escaping) {\n          // no need\n          escaping = false\n        } else if (reSpecials[c]\n                   && !(c === \"^\" && inClass)) {\n          re += \"\\\\\"\n        }\n\n        re += c\n\n    } // switch\n  } // for\n\n\n  // handle the case where we left a class open.\n  // \"[abc\" is valid, equivalent to \"\\[abc\"\n  if (inClass) {\n    // split where the last [ was, and escape it\n    // this is a huge pita.  We now have to re-walk\n    // the contents of the would-be class to re-translate\n    // any characters that were passed through as-is\n    var cs = pattern.substr(classStart + 1)\n      , sp = this.parse(cs, SUBPARSE)\n    re = re.substr(0, reClassStart) + \"\\\\[\" + sp[0]\n    hasMagic = hasMagic || sp[1]\n  }\n\n  // handle the case where we had a +( thing at the *end*\n  // of the pattern.\n  // each pattern list stack adds 3 chars, and we need to go through\n  // and escape any | chars that were passed through as-is for the regexp.\n  // Go through and escape them, taking care not to double-escape any\n  // | chars that were already escaped.\n  var pl\n  while (pl = patternListStack.pop()) {\n    var tail = re.slice(pl.reStart + 3)\n    // maybe some even number of \\, then maybe 1 \\, followed by a |\n    tail = tail.replace(/((?:\\\\{2})*)(\\\\?)\\|/g, function (_, $1, $2) {\n      if (!$2) {\n        // the | isn't already escaped, so escape it.\n        $2 = \"\\\\\"\n      }\n\n      // need to escape all those slashes *again*, without escaping the\n      // one that we need for escaping the | character.  As it works out,\n      // escaping an even number of slashes can be done by simply repeating\n      // it exactly after itself.  That's why this trick works.\n      //\n      // I am sorry that you have to see this.\n      return $1 + $1 + $2 + \"|\"\n    })\n\n    this.debug(\"tail=%j\\n   %s\", tail, tail)\n    var t = pl.type === \"*\" ? star\n          : pl.type === \"?\" ? qmark\n          : \"\\\\\" + pl.type\n\n    hasMagic = true\n    re = re.slice(0, pl.reStart)\n       + t + \"\\\\(\"\n       + tail\n  }\n\n  // handle trailing things that only matter at the very end.\n  clearStateChar()\n  if (escaping) {\n    // trailing \\\\\n    re += \"\\\\\\\\\"\n  }\n\n  // only need to apply the nodot start if the re starts with\n  // something that could conceivably capture a dot\n  var addPatternStart = false\n  switch (re.charAt(0)) {\n    case \".\":\n    case \"[\":\n    case \"(\": addPatternStart = true\n  }\n\n  // if the re is not \"\" at this point, then we need to make sure\n  // it doesn't match against an empty path part.\n  // Otherwise a/* will match a/, which it should not.\n  if (re !== \"\" && hasMagic) re = \"(?=.)\" + re\n\n  if (addPatternStart) re = patternStart + re\n\n  // parsing just a piece of a larger pattern.\n  if (isSub === SUBPARSE) {\n    return [ re, hasMagic ]\n  }\n\n  // skip the regexp for non-magical patterns\n  // unescape anything in it, though, so that it'll be\n  // an exact match against a file etc.\n  if (!hasMagic) {\n    return globUnescape(pattern)\n  }\n\n  var flags = options.nocase ? \"i\" : \"\"\n    , regExp = new RegExp(\"^\" + re + \"$\", flags)\n\n  regExp._glob = pattern\n  regExp._src = re\n\n  return regExp\n}\n\nminimatch.makeRe = function (pattern, options) {\n  return new Minimatch(pattern, options || {}).makeRe()\n}\n\nMinimatch.prototype.makeRe = makeRe\nfunction makeRe () {\n  if (this.regexp || this.regexp === false) return this.regexp\n\n  // at this point, this.set is a 2d array of partial\n  // pattern strings, or \"**\".\n  //\n  // It's better to use .match().  This function shouldn't\n  // be used, really, but it's pretty convenient sometimes,\n  // when you just want to work with a regex.\n  var set = this.set\n\n  if (!set.length) return this.regexp = false\n  var options = this.options\n\n  var twoStar = options.noglobstar ? star\n      : options.dot ? twoStarDot\n      : twoStarNoDot\n    , flags = options.nocase ? \"i\" : \"\"\n\n  var re = set.map(function (pattern) {\n    return pattern.map(function (p) {\n      return (p === GLOBSTAR) ? twoStar\n           : (typeof p === \"string\") ? regExpEscape(p)\n           : p._src\n    }).join(\"\\\\\\/\")\n  }).join(\"|\")\n\n  // must match entire pattern\n  // ending in a * or ** will make it less strict.\n  re = \"^(?:\" + re + \")$\"\n\n  // can match anything, as long as it's not this.\n  if (this.negate) re = \"^(?!\" + re + \").*$\"\n\n  try {\n    return this.regexp = new RegExp(re, flags)\n  } catch (ex) {\n    return this.regexp = false\n  }\n}\n\nminimatch.match = function (list, pattern, options) {\n  var mm = new Minimatch(pattern, options)\n  list = list.filter(function (f) {\n    return mm.match(f)\n  })\n  if (options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\n\nMinimatch.prototype.match = match\nfunction match (f, partial) {\n  this.debug(\"match\", f, this.pattern)\n  // short-circuit in the case of busted things.\n  // comments, etc.\n  if (this.comment) return false\n  if (this.empty) return f === \"\"\n\n  if (f === \"/\" && partial) return true\n\n  var options = this.options\n\n  // windows: need to use /, not \\\n  // On other platforms, \\ is a valid (albeit bad) filename char.\n  if (platform === \"win32\") {\n    f = f.split(\"\\\\\").join(\"/\")\n  }\n\n  // treat the test path as a set of pathparts.\n  f = f.split(slashSplit)\n  this.debug(this.pattern, \"split\", f)\n\n  // just ONE of the pattern sets in this.set needs to match\n  // in order for it to be valid.  If negating, then just one\n  // match means that we have failed.\n  // Either way, return on the first hit.\n\n  var set = this.set\n  this.debug(this.pattern, \"set\", set)\n\n  var splitFile = path.basename(f.join(\"/\")).split(\"/\")\n\n  for (var i = 0, l = set.length; i < l; i ++) {\n    var pattern = set[i], file = f\n    if (options.matchBase && pattern.length === 1) {\n      file = splitFile\n    }\n    var hit = this.matchOne(file, pattern, partial)\n    if (hit) {\n      if (options.flipNegate) return true\n      return !this.negate\n    }\n  }\n\n  // didn't get any hits.  this is success if it's a negative\n  // pattern, failure otherwise.\n  if (options.flipNegate) return false\n  return this.negate\n}\n\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\n  var options = this.options\n\n  this.debug(\"matchOne\",\n              { \"this\": this\n              , file: file\n              , pattern: pattern })\n\n  this.debug(\"matchOne\", file.length, pattern.length)\n\n  for ( var fi = 0\n          , pi = 0\n          , fl = file.length\n          , pl = pattern.length\n      ; (fi < fl) && (pi < pl)\n      ; fi ++, pi ++ ) {\n\n    this.debug(\"matchOne loop\")\n    var p = pattern[pi]\n      , f = file[fi]\n\n    this.debug(pattern, p, f)\n\n    // should be impossible.\n    // some invalid regexp stuff in the set.\n    if (p === false) return false\n\n    if (p === GLOBSTAR) {\n      this.debug('GLOBSTAR', [pattern, p, f])\n\n      // \"**\"\n      // a/**/b/**/c would match the following:\n      // a/b/x/y/z/c\n      // a/x/y/z/b/c\n      // a/b/x/b/x/c\n      // a/b/c\n      // To do this, take the rest of the pattern after\n      // the **, and see if it would match the file remainder.\n      // If so, return success.\n      // If not, the ** \"swallows\" a segment, and try again.\n      // This is recursively awful.\n      //\n      // a/**/b/**/c matching a/b/x/y/z/c\n      // - a matches a\n      // - doublestar\n      //   - matchOne(b/x/y/z/c, b/**/c)\n      //     - b matches b\n      //     - doublestar\n      //       - matchOne(x/y/z/c, c) -> no\n      //       - matchOne(y/z/c, c) -> no\n      //       - matchOne(z/c, c) -> no\n      //       - matchOne(c, c) yes, hit\n      var fr = fi\n        , pr = pi + 1\n      if (pr === pl) {\n        this.debug('** at the end')\n        // a ** at the end will just swallow the rest.\n        // We have found a match.\n        // however, it will not swallow /.x, unless\n        // options.dot is set.\n        // . and .. are *never* matched by **, for explosively\n        // exponential reasons.\n        for ( ; fi < fl; fi ++) {\n          if (file[fi] === \".\" || file[fi] === \"..\" ||\n              (!options.dot && file[fi].charAt(0) === \".\")) return false\n        }\n        return true\n      }\n\n      // ok, let's see if we can swallow whatever we can.\n      WHILE: while (fr < fl) {\n        var swallowee = file[fr]\n\n        this.debug('\\nglobstar while',\n                    file, fr, pattern, pr, swallowee)\n\n        // XXX remove this slice.  Just pass the start index.\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n          this.debug('globstar found match!', fr, fl, swallowee)\n          // found a match.\n          return true\n        } else {\n          // can't swallow \".\" or \"..\" ever.\n          // can only swallow \".foo\" when explicitly asked.\n          if (swallowee === \".\" || swallowee === \"..\" ||\n              (!options.dot && swallowee.charAt(0) === \".\")) {\n            this.debug(\"dot detected!\", file, fr, pattern, pr)\n            break WHILE\n          }\n\n          // ** swallows a segment, and continue.\n          this.debug('globstar swallow a segment, and continue')\n          fr ++\n        }\n      }\n      // no match was found.\n      // However, in partial mode, we can't say this is necessarily over.\n      // If there's more *pattern* left, then \n      if (partial) {\n        // ran out of file\n        this.debug(\"\\n>>> no match, partial?\", file, fr, pattern, pr)\n        if (fr === fl) return true\n      }\n      return false\n    }\n\n    // something other than **\n    // non-magic patterns just have to match exactly\n    // patterns with magic have been turned into regexps.\n    var hit\n    if (typeof p === \"string\") {\n      if (options.nocase) {\n        hit = f.toLowerCase() === p.toLowerCase()\n      } else {\n        hit = f === p\n      }\n      this.debug(\"string match\", p, f, hit)\n    } else {\n      hit = f.match(p)\n      this.debug(\"pattern match\", p, f, hit)\n    }\n\n    if (!hit) return false\n  }\n\n  // Note: ending in / means that we'll get a final \"\"\n  // at the end of the pattern.  This can only match a\n  // corresponding \"\" at the end of the file.\n  // If the file ends in /, then it can only match a\n  // a pattern that ends in /, unless the pattern just\n  // doesn't have any more for it. But, a/b/ should *not*\n  // match \"a/b/*\", even though \"\" matches against the\n  // [^/]*? pattern, except in partial mode, where it might\n  // simply not be reached yet.\n  // However, a/b/ should still satisfy a/*\n\n  // now either we fell off the end of the pattern, or we're done.\n  if (fi === fl && pi === pl) {\n    // ran out of pattern and filename at the same time.\n    // an exact hit!\n    return true\n  } else if (fi === fl) {\n    // ran out of file, but still had pattern left.\n    // this is ok if we're doing the match as part of\n    // a glob fs traversal.\n    return partial\n  } else if (pi === pl) {\n    // ran out of pattern, still have file left.\n    // this is only acceptable if we're on the very last\n    // empty segment of a file with a trailing slash.\n    // a/* should match a/b/\n    var emptyFileEnd = (fi === fl - 1) && (file[fi] === \"\")\n    return emptyFileEnd\n  }\n\n  // should be unreachable.\n  throw new Error(\"wtf?\")\n}\n\n\n// replace stuff like \\* with *\nfunction globUnescape (s) {\n  return s.replace(/\\\\(.)/g, \"$1\")\n}\n\n\nfunction regExpEscape (s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\")\n}\n\n})( typeof require === \"function\" ? require : null,\n    this,\n    typeof module === \"object\" ? module : null,\n    typeof process === \"object\" ? process.platform : \"win32\"\n  )\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}