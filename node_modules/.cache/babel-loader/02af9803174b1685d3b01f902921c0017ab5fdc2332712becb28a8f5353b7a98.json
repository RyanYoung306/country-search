{"ast":null,"code":"/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function (define) {\n  'use strict';\n\n  define(function () {\n    return function generate(Promise) {\n      var resolve = Promise.resolve;\n      Promise.iterate = iterate;\n      Promise.unfold = unfold;\n      return Promise;\n\n      /**\n       * Generate a (potentially infinite) stream of promised values:\n       * x, f(x), f(f(x)), etc. until condition(x) returns true\n       * @param {function} f function to generate a new x from the previous x\n       * @param {function} condition function that, given the current x, returns\n       *  truthy when the iterate should stop\n       * @param {function} handler function to handle the value produced by f\n       * @param {*|Promise} x starting value, may be a promise\n       * @return {Promise} the result of the last call to f before\n       *  condition returns true\n       */\n      function iterate(f, condition, handler, x) {\n        return resolve(x).then(function (x) {\n          return resolve(condition(x)).then(function (done) {\n            return done ? x : next(x);\n          });\n        });\n        function next(nextValue) {\n          return resolve(handler(nextValue)).then(function () {\n            return iterate(f, condition, handler, f(nextValue));\n          });\n        }\n      }\n\n      /**\n       * Generate a (potentially infinite) stream of promised values\n       * by applying handler(generator(seed)) iteratively until\n       * condition(seed) returns true.\n       * @param {function} unspool function that generates a [value, newSeed]\n       *  given a seed.\n       * @param {function} condition function that, given the current seed, returns\n       *  truthy when the unfold should stop\n       * @param {function} handler function to handle the value produced by unspool\n       * @param x {*|Promise} starting value, may be a promise\n       * @return {Promise} the result of the last value produced by unspool before\n       *  condition returns true\n       */\n      function unfold(unspool, condition, handler, x) {\n        return resolve(x).then(function (seed) {\n          return resolve(condition(seed)).then(function (done) {\n            return done ? seed : resolve(unspool(seed)).spread(next);\n          });\n        });\n        function next(item, newSeed) {\n          return resolve(handler(item)).then(function () {\n            return unfold(unspool, condition, handler, newSeed);\n          });\n        }\n      }\n    };\n  });\n})(typeof define === 'function' && define.amd ? define : function (factory) {\n  module.exports = factory();\n});","map":{"version":3,"names":["define","generate","Promise","resolve","iterate","unfold","f","condition","handler","x","then","done","next","nextValue","unspool","seed","spread","item","newSeed","amd","factory","module","exports"],"sources":["C:/Users/twotr/Desktop/College/vsCode/WorkHumanApplication/country-search/node_modules/scatter/node_modules/when/lib/iterate.js"],"sourcesContent":["/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn function generate(Promise) {\n\n\t\tvar resolve = Promise.resolve;\n\n\t\tPromise.iterate = iterate;\n\t\tPromise.unfold = unfold;\n\n\t\treturn Promise;\n\n\t\t/**\n\t\t * Generate a (potentially infinite) stream of promised values:\n\t\t * x, f(x), f(f(x)), etc. until condition(x) returns true\n\t\t * @param {function} f function to generate a new x from the previous x\n\t\t * @param {function} condition function that, given the current x, returns\n\t\t *  truthy when the iterate should stop\n\t\t * @param {function} handler function to handle the value produced by f\n\t\t * @param {*|Promise} x starting value, may be a promise\n\t\t * @return {Promise} the result of the last call to f before\n\t\t *  condition returns true\n\t\t */\n\t\tfunction iterate(f, condition, handler, x) {\n\t\t\treturn resolve(x).then(function(x) {\n\t\t\t\treturn resolve(condition(x)).then(function(done) {\n\t\t\t\t\treturn done ? x : next(x);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tfunction next(nextValue) {\n\t\t\t\treturn resolve(handler(nextValue)).then(function() {\n\t\t\t\t\treturn iterate(f, condition, handler, f(nextValue));\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Generate a (potentially infinite) stream of promised values\n\t\t * by applying handler(generator(seed)) iteratively until\n\t\t * condition(seed) returns true.\n\t\t * @param {function} unspool function that generates a [value, newSeed]\n\t\t *  given a seed.\n\t\t * @param {function} condition function that, given the current seed, returns\n\t\t *  truthy when the unfold should stop\n\t\t * @param {function} handler function to handle the value produced by unspool\n\t\t * @param x {*|Promise} starting value, may be a promise\n\t\t * @return {Promise} the result of the last value produced by unspool before\n\t\t *  condition returns true\n\t\t */\n\t\tfunction unfold(unspool, condition, handler, x) {\n\t\t\treturn resolve(x).then(function(seed) {\n\t\t\t\treturn resolve(condition(seed)).then(function(done) {\n\t\t\t\t\treturn done ? seed : resolve(unspool(seed)).spread(next);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tfunction next(item, newSeed) {\n\t\t\t\treturn resolve(handler(item)).then(function() {\n\t\t\t\t\treturn unfold(unspool, condition, handler, newSeed);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t};\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n"],"mappings":"AAAA;AACA;AACA;;AAEC,WAASA,MAAM,EAAE;EAAE,YAAY;;EAChCA,MAAM,CAAC,YAAW;IAEjB,OAAO,SAASC,QAAQA,CAACC,OAAO,EAAE;MAEjC,IAAIC,OAAO,GAAGD,OAAO,CAACC,OAAO;MAE7BD,OAAO,CAACE,OAAO,GAAGA,OAAO;MACzBF,OAAO,CAACG,MAAM,GAAGA,MAAM;MAEvB,OAAOH,OAAO;;MAEd;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACE,SAASE,OAAOA,CAACE,CAAC,EAAEC,SAAS,EAAEC,OAAO,EAAEC,CAAC,EAAE;QAC1C,OAAON,OAAO,CAACM,CAAC,CAAC,CAACC,IAAI,CAAC,UAASD,CAAC,EAAE;UAClC,OAAON,OAAO,CAACI,SAAS,CAACE,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,UAASC,IAAI,EAAE;YAChD,OAAOA,IAAI,GAAGF,CAAC,GAAGG,IAAI,CAACH,CAAC,CAAC;UAC1B,CAAC,CAAC;QACH,CAAC,CAAC;QAEF,SAASG,IAAIA,CAACC,SAAS,EAAE;UACxB,OAAOV,OAAO,CAACK,OAAO,CAACK,SAAS,CAAC,CAAC,CAACH,IAAI,CAAC,YAAW;YAClD,OAAON,OAAO,CAACE,CAAC,EAAEC,SAAS,EAAEC,OAAO,EAAEF,CAAC,CAACO,SAAS,CAAC,CAAC;UACpD,CAAC,CAAC;QACH;MACD;;MAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACE,SAASR,MAAMA,CAACS,OAAO,EAAEP,SAAS,EAAEC,OAAO,EAAEC,CAAC,EAAE;QAC/C,OAAON,OAAO,CAACM,CAAC,CAAC,CAACC,IAAI,CAAC,UAASK,IAAI,EAAE;UACrC,OAAOZ,OAAO,CAACI,SAAS,CAACQ,IAAI,CAAC,CAAC,CAACL,IAAI,CAAC,UAASC,IAAI,EAAE;YACnD,OAAOA,IAAI,GAAGI,IAAI,GAAGZ,OAAO,CAACW,OAAO,CAACC,IAAI,CAAC,CAAC,CAACC,MAAM,CAACJ,IAAI,CAAC;UACzD,CAAC,CAAC;QACH,CAAC,CAAC;QAEF,SAASA,IAAIA,CAACK,IAAI,EAAEC,OAAO,EAAE;UAC5B,OAAOf,OAAO,CAACK,OAAO,CAACS,IAAI,CAAC,CAAC,CAACP,IAAI,CAAC,YAAW;YAC7C,OAAOL,MAAM,CAACS,OAAO,EAAEP,SAAS,EAAEC,OAAO,EAAEU,OAAO,CAAC;UACpD,CAAC,CAAC;QACH;MACD;IACD,CAAC;EAEF,CAAC,CAAC;AACF,CAAC,EAAC,OAAOlB,MAAM,KAAK,UAAU,IAAIA,MAAM,CAACmB,GAAG,GAAGnB,MAAM,GAAG,UAASoB,OAAO,EAAE;EAAEC,MAAM,CAACC,OAAO,GAAGF,OAAO,CAAC,CAAC;AAAE,CAAC,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}