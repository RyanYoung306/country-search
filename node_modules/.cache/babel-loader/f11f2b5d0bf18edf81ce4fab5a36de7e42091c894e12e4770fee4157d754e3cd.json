{"ast":null,"code":"/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function (define) {\n  'use strict';\n\n  define(function () {\n    return function makePromise(environment) {\n      var foreverPendingPromise;\n      var tasks = environment.scheduler;\n      var objectCreate = Object.create || function (proto) {\n        function Child() {}\n        Child.prototype = proto;\n        return new Child();\n      };\n\n      /**\n       * Create a promise whose fate is determined by resolver\n       * @constructor\n       * @returns {Promise} promise\n       * @name Promise\n       */\n      function Promise(resolver) {\n        var self = this;\n        this._handler = new DeferredHandler();\n        runResolver(resolver, promiseResolve, promiseReject, promiseNotify);\n\n        /**\n         * Transition from pre-resolution state to post-resolution state, notifying\n         * all listeners of the ultimate fulfillment or rejection\n         * @param {*} x resolution value\n         */\n        function promiseResolve(x) {\n          self._handler.resolve(x);\n        }\n        /**\n         * Reject this promise with reason, which will be used verbatim\n         * @param {*} reason reason for the rejection, typically an Error\n         */\n        function promiseReject(reason) {\n          self._handler.reject(reason);\n        }\n\n        /**\n         * Issue a progress event, notifying all progress listeners\n         * @param {*} x progress event payload to pass to all listeners\n         */\n        function promiseNotify(x) {\n          self._handler.notify(x);\n        }\n      }\n      function runResolver(resolver, promiseResolve, promiseReject, promiseNotify) {\n        try {\n          resolver(promiseResolve, promiseReject, promiseNotify);\n        } catch (e) {\n          promiseReject(e);\n        }\n      }\n\n      // Creation\n\n      Promise.resolve = resolve;\n      Promise.reject = reject;\n      Promise.never = never;\n      Promise._defer = defer;\n\n      /**\n       * Returns a trusted promise. If x is already a trusted promise, it is\n       * returned, otherwise returns a new trusted Promise which follows x.\n       * @param  {*} x\n       * @return {Promise} promise\n       */\n      function resolve(x) {\n        return x instanceof Promise ? x : new InternalPromise(new AsyncHandler(getHandler(x)));\n      }\n\n      /**\n       * Return a reject promise with x as its reason (x is used verbatim)\n       * @param {*} x\n       * @returns {Promise} rejected promise\n       */\n      function reject(x) {\n        return new InternalPromise(new AsyncHandler(new RejectedHandler(x)));\n      }\n\n      /**\n       * Return a promise that remains pending forever\n       * @returns {Promise} forever-pending promise.\n       */\n      function never() {\n        return foreverPendingPromise; // Should be frozen\n      }\n\n      /**\n       * Creates an internal {promise, resolver} pair\n       * @private\n       * @returns {{resolver: DeferredHandler, promise: InternalPromise}}\n       */\n      function defer() {\n        return new InternalPromise(new DeferredHandler());\n      }\n\n      // Transformation and flow control\n\n      /**\n       * Transform this promise's fulfillment value, returning a new Promise\n       * for the transformed result.  If the promise cannot be fulfilled, onRejected\n       * is called with the reason.  onProgress *may* be called with updates toward\n       * this promise's fulfillment.\n       * @param [onFulfilled] {Function} fulfillment handler\n       * @param [onRejected] {Function} rejection handler\n       * @param [onProgress] {Function} progress handler\n       * @return {Promise} new promise\n       */\n      Promise.prototype.then = function (onFulfilled, onRejected, onProgress) {\n        var from = this._handler;\n        var to = new DeferredHandler(from.receiver);\n        from.when(to.resolve, to.notify, to, from.receiver, onFulfilled, onRejected, onProgress);\n        return new InternalPromise(to);\n      };\n\n      /**\n       * If this promise cannot be fulfilled due to an error, call onRejected to\n       * handle the error. Shortcut for .then(undefined, onRejected)\n       * @param {function?} onRejected\n       * @return {Promise}\n       */\n      Promise.prototype['catch'] = Promise.prototype.otherwise = function (onRejected) {\n        return this.then(void 0, onRejected);\n      };\n\n      /**\n       * Private function to bind a thisArg for this promise's handlers\n       * @private\n       * @param {object} thisArg `this` value for all handlers attached to\n       *  the returned promise.\n       * @returns {Promise}\n       */\n      Promise.prototype._bindContext = function (thisArg) {\n        return new InternalPromise(new BoundHandler(this._handler, thisArg));\n      };\n\n      // Array combinators\n\n      Promise.all = all;\n      Promise.race = race;\n\n      /**\n       * Return a promise that will fulfill when all promises in the\n       * input array have fulfilled, or will reject when one of the\n       * promises rejects.\n       * @param {array} promises array of promises\n       * @returns {Promise} promise for array of fulfillment values\n       */\n      function all(promises) {\n        /*jshint maxcomplexity:6*/\n        var resolver = new DeferredHandler();\n        var len = promises.length >>> 0;\n        var pending = len;\n        var results = [];\n        var i, x;\n        for (i = 0; i < len; ++i) {\n          if (i in promises) {\n            x = promises[i];\n            if (maybeThenable(x)) {\n              resolveOne(resolver, results, getHandlerThenable(x), i);\n            } else {\n              results[i] = x;\n              --pending;\n            }\n          } else {\n            --pending;\n          }\n        }\n        if (pending === 0) {\n          resolver.resolve(results);\n        }\n        return new InternalPromise(resolver);\n        function resolveOne(resolver, results, handler, i) {\n          handler.when(noop, noop, void 0, resolver, function (x) {\n            results[i] = x;\n            if (--pending === 0) {\n              this.resolve(results);\n            }\n          }, resolver.reject, resolver.notify);\n        }\n      }\n\n      /**\n       * Fulfill-reject competitive race. Return a promise that will settle\n       * to the same state as the earliest input promise to settle.\n       *\n       * WARNING: The ES6 Promise spec requires that race()ing an empty array\n       * must return a promise that is pending forever.  This implementation\n       * returns a singleton forever-pending promise, the same singleton that is\n       * returned by Promise.never(), thus can be checked with ===\n       *\n       * @param {array} promises array of promises to race\n       * @returns {Promise} if input is non-empty, a promise that will settle\n       * to the same outcome as the earliest input promise to settle. if empty\n       * is empty, returns a promise that will never settle.\n       */\n      function race(promises) {\n        // Sigh, race([]) is untestable unless we return *something*\n        // that is recognizable without calling .then() on it.\n        if (Object(promises) === promises && promises.length === 0) {\n          return never();\n        }\n        var h = new DeferredHandler();\n        for (var i = 0; i < promises.length; ++i) {\n          getHandler(promises[i]).when(noop, noop, void 0, h, h.resolve, h.reject);\n        }\n        return new InternalPromise(h);\n      }\n\n      // Promise internals\n\n      /**\n       * InternalPromise represents a promise that is either already\n       * fulfilled or reject, or is following another promise, based\n       * on the provided handler.\n       * @private\n       * @param {object} handler\n       * @constructor\n       */\n      function InternalPromise(handler) {\n        this._handler = handler;\n      }\n      InternalPromise.prototype = objectCreate(Promise.prototype);\n\n      /**\n       * Get an appropriate handler for x, checking for untrusted thenables\n       * and promise graph cycles.\n       * @private\n       * @param {*} x\n       * @param {object?} h optional handler to check for cycles\n       * @returns {object} handler\n       */\n      function getHandler(x, h) {\n        if (x instanceof Promise) {\n          return getHandlerChecked(x, h);\n        }\n        return maybeThenable(x) ? getHandlerUntrusted(x) : new FulfilledHandler(x);\n      }\n\n      /**\n       * Get an appropriate handler for x, which must be either a thenable\n       * @param {object} x\n       * @returns {object} handler\n       */\n      function getHandlerThenable(x) {\n        return x instanceof Promise ? x._handler.join() : getHandlerUntrusted(x);\n      }\n\n      /**\n       * Get x's handler, checking for cycles\n       * @param {Promise} x\n       * @param {object?} h handler to check for cycles\n       * @returns {object} handler\n       */\n      function getHandlerChecked(x, h) {\n        var xh = x._handler.join();\n        return h === xh ? promiseCycleHandler() : xh;\n      }\n\n      /**\n       * Get a handler for potentially untrusted thenable x\n       * @param {*} x\n       * @returns {object} handler\n       */\n      function getHandlerUntrusted(x) {\n        try {\n          var untrustedThen = x.then;\n          return typeof untrustedThen === 'function' ? new ThenableHandler(untrustedThen, x) : new FulfilledHandler(x);\n        } catch (e) {\n          return new RejectedHandler(e);\n        }\n      }\n\n      /**\n       * Handler for a promise that is pending forever\n       * @private\n       * @constructor\n       */\n      function Handler() {}\n      Handler.prototype.inspect = toPendingState;\n      Handler.prototype.when = noop;\n      Handler.prototype.resolve = noop;\n      Handler.prototype.reject = noop;\n      Handler.prototype.notify = noop;\n      Handler.prototype.join = function () {\n        return this;\n      };\n      Handler.prototype._env = environment.monitor || Promise;\n      Handler.prototype._addTrace = noop;\n      Handler.prototype._isMonitored = function () {\n        return typeof this._env.promiseMonitor !== 'undefined';\n      };\n\n      /**\n       * Abstract base for handler that delegates to another handler\n       * @private\n       * @param {object} handler\n       * @constructor\n       */\n      function DelegateHandler(handler) {\n        this.handler = handler;\n        if (this._isMonitored()) {\n          var trace = this._env.promiseMonitor.captureStack();\n          this.trace = handler._addTrace(trace);\n        }\n      }\n      DelegateHandler.prototype = objectCreate(Handler.prototype);\n      DelegateHandler.prototype.join = function () {\n        return this.handler.join();\n      };\n      DelegateHandler.prototype.inspect = function () {\n        return this.handler.inspect();\n      };\n      DelegateHandler.prototype._addTrace = function (trace) {\n        return this.handler._addTrace(trace);\n      };\n\n      /**\n       * Handler that manages a queue of consumers waiting on a pending promise\n       * @private\n       * @constructor\n       */\n      function DeferredHandler(receiver) {\n        this.consumers = [];\n        this.receiver = receiver;\n        this.handler = void 0;\n        this.resolved = false;\n        if (this._isMonitored()) {\n          this.trace = this._env.promiseMonitor.captureStack();\n        }\n      }\n      DeferredHandler.prototype = objectCreate(Handler.prototype);\n      DeferredHandler.prototype.inspect = function () {\n        return this.resolved ? this.handler.join().inspect() : toPendingState();\n      };\n      DeferredHandler.prototype.resolve = function (x) {\n        this._join(getHandler(x, this));\n      };\n      DeferredHandler.prototype.reject = function (x) {\n        this._join(new RejectedHandler(x));\n      };\n      DeferredHandler.prototype.join = function () {\n        return this.resolved ? this.handler.join() : this;\n      };\n      DeferredHandler.prototype.run = function () {\n        var q = this.consumers;\n        var handler = this.handler = this.handler.join();\n        this.consumers = void 0;\n        for (var i = 0; i < q.length; i += 7) {\n          handler.when(q[i], q[i + 1], q[i + 2], q[i + 3], q[i + 4], q[i + 5], q[i + 6]);\n        }\n      };\n      DeferredHandler.prototype._join = function (handler) {\n        if (this.resolved) {\n          return;\n        }\n        this.resolved = true;\n        this.handler = handler;\n        tasks.enqueue(this);\n        if (this._isMonitored()) {\n          this.trace = handler._addTrace(this.trace);\n        }\n      };\n      DeferredHandler.prototype.when = function (resolve, notify, t, receiver, f, r, u) {\n        if (this.resolved) {\n          tasks.enqueue(new RunHandlerTask(resolve, notify, t, receiver, f, r, u, this.handler.join()));\n        } else {\n          this.consumers.push(resolve, notify, t, receiver, f, r, u);\n        }\n      };\n      DeferredHandler.prototype.notify = function (x) {\n        if (!this.resolved) {\n          tasks.enqueue(new ProgressTask(this.consumers, x));\n        }\n      };\n      DeferredHandler.prototype._addTrace = function (trace) {\n        return this.resolved ? this.handler._addTrace(trace) : trace;\n      };\n\n      /**\n       * Wrap another handler and force it into a future stack\n       * @private\n       * @param {object} handler\n       * @constructor\n       */\n      function AsyncHandler(handler) {\n        DelegateHandler.call(this, handler);\n      }\n      AsyncHandler.prototype = objectCreate(DelegateHandler.prototype);\n      AsyncHandler.prototype.when = function (resolve, notify, t, receiver, f, r, u) {\n        tasks.enqueue(new RunHandlerTask(resolve, notify, t, receiver, f, r, u, this.join()));\n      };\n\n      /**\n       * Handler that follows another handler, injecting a receiver\n       * @private\n       * @param {object} handler another handler to follow\n       * @param {object=undefined} receiver\n       * @constructor\n       */\n      function BoundHandler(handler, receiver) {\n        DelegateHandler.call(this, handler);\n        this.receiver = receiver;\n      }\n      BoundHandler.prototype = objectCreate(DelegateHandler.prototype);\n      BoundHandler.prototype.when = function (resolve, notify, t, receiver, f, r, u) {\n        // Because handlers are allowed to be shared among promises,\n        // each of which possibly having a different receiver, we have\n        // to insert our own receiver into the chain if it has been set\n        // so that callbacks (f, r, u) will be called using our receiver\n        if (this.receiver !== void 0) {\n          receiver = this.receiver;\n        }\n        this.join().when(resolve, notify, t, receiver, f, r, u);\n      };\n\n      /**\n       * Handler that wraps an untrusted thenable and assimilates it in a future stack\n       * @private\n       * @param {function} then\n       * @param {{then: function}} thenable\n       * @constructor\n       */\n      function ThenableHandler(then, thenable) {\n        DeferredHandler.call(this);\n        this.assimilated = false;\n        this.untrustedThen = then;\n        this.thenable = thenable;\n      }\n      ThenableHandler.prototype = objectCreate(DeferredHandler.prototype);\n      ThenableHandler.prototype.when = function (resolve, notify, t, receiver, f, r, u) {\n        if (!this.assimilated) {\n          this.assimilated = true;\n          this._assimilate();\n        }\n        DeferredHandler.prototype.when.call(this, resolve, notify, t, receiver, f, r, u);\n      };\n      ThenableHandler.prototype._assimilate = function () {\n        var h = this;\n        this._try(this.untrustedThen, this.thenable, _resolve, _reject, _notify);\n        function _resolve(x) {\n          h.resolve(x);\n        }\n        function _reject(x) {\n          h.reject(x);\n        }\n        function _notify(x) {\n          h.notify(x);\n        }\n      };\n      ThenableHandler.prototype._try = function (then, thenable, resolve, reject, notify) {\n        try {\n          then.call(thenable, resolve, reject, notify);\n        } catch (e) {\n          reject(e);\n        }\n      };\n\n      /**\n       * Handler for a fulfilled promise\n       * @private\n       * @param {*} x fulfillment value\n       * @constructor\n       */\n      function FulfilledHandler(x) {\n        this.value = x;\n      }\n      FulfilledHandler.prototype = objectCreate(Handler.prototype);\n      FulfilledHandler.prototype.inspect = function () {\n        return toFulfilledState(this.value);\n      };\n      FulfilledHandler.prototype.when = function (resolve, notify, t, receiver, f) {\n        var x = typeof f === 'function' ? tryCatchReject(f, this.value, receiver) : this.value;\n        resolve.call(t, x);\n      };\n\n      /**\n       * Handler for a rejected promise\n       * @private\n       * @param {*} x rejection reason\n       * @constructor\n       */\n      function RejectedHandler(x) {\n        this.value = x;\n        this.observed = false;\n        if (this._isMonitored()) {\n          this.key = this._env.promiseMonitor.startTrace(x);\n        }\n      }\n      RejectedHandler.prototype = objectCreate(Handler.prototype);\n      RejectedHandler.prototype.inspect = function () {\n        return toRejectedState(this.value);\n      };\n      RejectedHandler.prototype.when = function (resolve, notify, t, receiver, f, r) {\n        if (this._isMonitored() && !this.observed) {\n          this._env.promiseMonitor.removeTrace(this.key);\n        }\n        this.observed = true;\n        var x = typeof r === 'function' ? tryCatchReject(r, this.value, receiver) : reject(this.value);\n        resolve.call(t, x);\n      };\n      RejectedHandler.prototype._addTrace = function (trace) {\n        if (!this.observed) {\n          this._env.promiseMonitor.updateTrace(this.key, trace);\n        }\n      };\n\n      // Errors and singletons\n\n      foreverPendingPromise = new InternalPromise(new Handler());\n      function promiseCycleHandler() {\n        return new RejectedHandler(new TypeError('Promise cycle'));\n      }\n\n      // Snapshot states\n\n      /**\n       * Creates a fulfilled state snapshot\n       * @private\n       * @param {*} x any value\n       * @returns {{state:'fulfilled',value:*}}\n       */\n      function toFulfilledState(x) {\n        return {\n          state: 'fulfilled',\n          value: x\n        };\n      }\n\n      /**\n       * Creates a rejected state snapshot\n       * @private\n       * @param {*} x any reason\n       * @returns {{state:'rejected',reason:*}}\n       */\n      function toRejectedState(x) {\n        return {\n          state: 'rejected',\n          reason: x\n        };\n      }\n\n      /**\n       * Creates a pending state snapshot\n       * @private\n       * @returns {{state:'pending'}}\n       */\n      function toPendingState() {\n        return {\n          state: 'pending'\n        };\n      }\n\n      // Task runners\n\n      /**\n       * Run a single consumer\n       * @private\n       * @constructor\n       */\n      function RunHandlerTask(a, b, c, d, e, f, g, handler) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n        this.e = e;\n        this.f = f;\n        this.g = g;\n        this.handler = handler;\n      }\n      RunHandlerTask.prototype.run = function () {\n        this.handler.when(this.a, this.b, this.c, this.d, this.e, this.f, this.g);\n      };\n\n      /**\n       * Run a queue of progress handlers\n       * @private\n       * @constructor\n       */\n      function ProgressTask(q, value) {\n        this.q = q;\n        this.value = value;\n      }\n      ProgressTask.prototype.run = function () {\n        var q = this.q;\n        // First progress handler is at index 1\n        for (var i = 1; i < q.length; i += 7) {\n          this._notify(q[i], q[i + 1], q[i + 2], q[i + 5]);\n        }\n      };\n      ProgressTask.prototype._notify = function (notify, t, receiver, u) {\n        var x = typeof u === 'function' ? tryCatchReturn(u, this.value, receiver) : this.value;\n        notify.call(t, x);\n      };\n\n      /**\n       * @param {*} x\n       * @returns {boolean} false iff x is guaranteed not to be a thenable\n       */\n      function maybeThenable(x) {\n        return (typeof x === 'object' || typeof x === 'function') && x !== null;\n      }\n\n      /**\n       * Return f.call(thisArg, x), or if it throws return a rejected promise for\n       * the thrown exception\n       * @private\n       */\n      function tryCatchReject(f, x, thisArg) {\n        try {\n          return f.call(thisArg, x);\n        } catch (e) {\n          return reject(e);\n        }\n      }\n\n      /**\n       * Return f.call(thisArg, x), or if it throws, *return* the exception\n       * @private\n       */\n      function tryCatchReturn(f, x, thisArg) {\n        try {\n          return f.call(thisArg, x);\n        } catch (e) {\n          return e;\n        }\n      }\n      function noop() {}\n      return Promise;\n    };\n  });\n})(typeof define === 'function' && define.amd ? define : function (factory) {\n  module.exports = factory();\n});","map":{"version":3,"names":["define","makePromise","environment","foreverPendingPromise","tasks","scheduler","objectCreate","Object","create","proto","Child","prototype","Promise","resolver","self","_handler","DeferredHandler","runResolver","promiseResolve","promiseReject","promiseNotify","x","resolve","reason","reject","notify","e","never","_defer","defer","InternalPromise","AsyncHandler","getHandler","RejectedHandler","then","onFulfilled","onRejected","onProgress","from","to","receiver","when","otherwise","_bindContext","thisArg","BoundHandler","all","race","promises","len","length","pending","results","i","maybeThenable","resolveOne","getHandlerThenable","handler","noop","h","getHandlerChecked","getHandlerUntrusted","FulfilledHandler","join","xh","promiseCycleHandler","untrustedThen","ThenableHandler","Handler","inspect","toPendingState","_env","monitor","_addTrace","_isMonitored","promiseMonitor","DelegateHandler","trace","captureStack","consumers","resolved","_join","run","q","enqueue","t","f","r","u","RunHandlerTask","push","ProgressTask","call","thenable","assimilated","_assimilate","_try","_resolve","_reject","_notify","value","toFulfilledState","tryCatchReject","observed","key","startTrace","toRejectedState","removeTrace","updateTrace","TypeError","state","a","b","c","d","g","tryCatchReturn","amd","factory","module","exports"],"sources":["C:/Users/twotr/Desktop/College/vsCode/WorkHumanApplication/country-search/node_modules/scatter/node_modules/when/lib/makePromise.js"],"sourcesContent":["/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn function makePromise(environment) {\n\n\t\tvar foreverPendingPromise;\n\t\tvar tasks = environment.scheduler;\n\n\t\tvar objectCreate = Object.create ||\n\t\t\tfunction(proto) {\n\t\t\t\tfunction Child() {}\n\t\t\t\tChild.prototype = proto;\n\t\t\t\treturn new Child();\n\t\t\t};\n\n\t\t/**\n\t\t * Create a promise whose fate is determined by resolver\n\t\t * @constructor\n\t\t * @returns {Promise} promise\n\t\t * @name Promise\n\t\t */\n\t\tfunction Promise(resolver) {\n\t\t\tvar self = this;\n\t\t\tthis._handler = new DeferredHandler();\n\n\t\t\trunResolver(resolver, promiseResolve, promiseReject, promiseNotify);\n\n\t\t\t/**\n\t\t\t * Transition from pre-resolution state to post-resolution state, notifying\n\t\t\t * all listeners of the ultimate fulfillment or rejection\n\t\t\t * @param {*} x resolution value\n\t\t\t */\n\t\t\tfunction promiseResolve (x) {\n\t\t\t\tself._handler.resolve(x);\n\t\t\t}\n\t\t\t/**\n\t\t\t * Reject this promise with reason, which will be used verbatim\n\t\t\t * @param {*} reason reason for the rejection, typically an Error\n\t\t\t */\n\t\t\tfunction promiseReject (reason) {\n\t\t\t\tself._handler.reject(reason);\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Issue a progress event, notifying all progress listeners\n\t\t\t * @param {*} x progress event payload to pass to all listeners\n\t\t\t */\n\t\t\tfunction promiseNotify (x) {\n\t\t\t\tself._handler.notify(x);\n\t\t\t}\n\t\t}\n\n\t\tfunction runResolver(resolver, promiseResolve, promiseReject, promiseNotify) {\n\t\t\ttry {\n\t\t\t\tresolver(promiseResolve, promiseReject, promiseNotify);\n\t\t\t} catch (e) {\n\t\t\t\tpromiseReject(e);\n\t\t\t}\n\t\t}\n\n\t\t// Creation\n\n\t\tPromise.resolve = resolve;\n\t\tPromise.reject = reject;\n\t\tPromise.never = never;\n\n\t\tPromise._defer = defer;\n\n\t\t/**\n\t\t * Returns a trusted promise. If x is already a trusted promise, it is\n\t\t * returned, otherwise returns a new trusted Promise which follows x.\n\t\t * @param  {*} x\n\t\t * @return {Promise} promise\n\t\t */\n\t\tfunction resolve(x) {\n\t\t\treturn x instanceof Promise ? x\n\t\t\t\t: new InternalPromise(new AsyncHandler(getHandler(x)));\n\t\t}\n\n\t\t/**\n\t\t * Return a reject promise with x as its reason (x is used verbatim)\n\t\t * @param {*} x\n\t\t * @returns {Promise} rejected promise\n\t\t */\n\t\tfunction reject(x) {\n\t\t\treturn new InternalPromise(new AsyncHandler(new RejectedHandler(x)));\n\t\t}\n\n\t\t/**\n\t\t * Return a promise that remains pending forever\n\t\t * @returns {Promise} forever-pending promise.\n\t\t */\n\t\tfunction never() {\n\t\t\treturn foreverPendingPromise; // Should be frozen\n\t\t}\n\n\t\t/**\n\t\t * Creates an internal {promise, resolver} pair\n\t\t * @private\n\t\t * @returns {{resolver: DeferredHandler, promise: InternalPromise}}\n\t\t */\n\t\tfunction defer() {\n\t\t\treturn new InternalPromise(new DeferredHandler());\n\t\t}\n\n\t\t// Transformation and flow control\n\n\t\t/**\n\t\t * Transform this promise's fulfillment value, returning a new Promise\n\t\t * for the transformed result.  If the promise cannot be fulfilled, onRejected\n\t\t * is called with the reason.  onProgress *may* be called with updates toward\n\t\t * this promise's fulfillment.\n\t\t * @param [onFulfilled] {Function} fulfillment handler\n\t\t * @param [onRejected] {Function} rejection handler\n\t\t * @param [onProgress] {Function} progress handler\n\t\t * @return {Promise} new promise\n\t\t */\n\t\tPromise.prototype.then = function(onFulfilled, onRejected, onProgress) {\n\t\t\tvar from = this._handler;\n\t\t\tvar to = new DeferredHandler(from.receiver);\n\t\t\tfrom.when(to.resolve, to.notify, to, from.receiver, onFulfilled, onRejected, onProgress);\n\n\t\t\treturn new InternalPromise(to);\n\t\t};\n\n\t\t/**\n\t\t * If this promise cannot be fulfilled due to an error, call onRejected to\n\t\t * handle the error. Shortcut for .then(undefined, onRejected)\n\t\t * @param {function?} onRejected\n\t\t * @return {Promise}\n\t\t */\n\t\tPromise.prototype['catch'] = Promise.prototype.otherwise = function(onRejected) {\n\t\t\treturn this.then(void 0, onRejected);\n\t\t};\n\n\t\t/**\n\t\t * Private function to bind a thisArg for this promise's handlers\n\t\t * @private\n\t\t * @param {object} thisArg `this` value for all handlers attached to\n\t\t *  the returned promise.\n\t\t * @returns {Promise}\n\t\t */\n\t\tPromise.prototype._bindContext = function(thisArg) {\n\t\t\treturn new InternalPromise(new BoundHandler(this._handler, thisArg));\n\t\t};\n\n\t\t// Array combinators\n\n\t\tPromise.all = all;\n\t\tPromise.race = race;\n\n\t\t/**\n\t\t * Return a promise that will fulfill when all promises in the\n\t\t * input array have fulfilled, or will reject when one of the\n\t\t * promises rejects.\n\t\t * @param {array} promises array of promises\n\t\t * @returns {Promise} promise for array of fulfillment values\n\t\t */\n\t\tfunction all(promises) {\n\t\t\t/*jshint maxcomplexity:6*/\n\t\t\tvar resolver = new DeferredHandler();\n\t\t\tvar len = promises.length >>> 0;\n\t\t\tvar pending = len;\n\t\t\tvar results = [];\n\t\t\tvar i, x;\n\n\t\t\tfor (i = 0; i < len; ++i) {\n\t\t\t\tif (i in promises) {\n\t\t\t\t\tx = promises[i];\n\t\t\t\t\tif (maybeThenable(x)) {\n\t\t\t\t\t\tresolveOne(resolver, results, getHandlerThenable(x), i);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresults[i] = x;\n\t\t\t\t\t\t--pending;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t--pending;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(pending === 0) {\n\t\t\t\tresolver.resolve(results);\n\t\t\t}\n\n\t\t\treturn new InternalPromise(resolver);\n\n\t\t\tfunction resolveOne(resolver, results, handler, i) {\n\t\t\t\thandler.when(noop, noop, void 0, resolver, function(x) {\n\t\t\t\t\tresults[i] = x;\n\t\t\t\t\tif(--pending === 0) {\n\t\t\t\t\t\tthis.resolve(results);\n\t\t\t\t\t}\n\t\t\t\t}, resolver.reject, resolver.notify);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Fulfill-reject competitive race. Return a promise that will settle\n\t\t * to the same state as the earliest input promise to settle.\n\t\t *\n\t\t * WARNING: The ES6 Promise spec requires that race()ing an empty array\n\t\t * must return a promise that is pending forever.  This implementation\n\t\t * returns a singleton forever-pending promise, the same singleton that is\n\t\t * returned by Promise.never(), thus can be checked with ===\n\t\t *\n\t\t * @param {array} promises array of promises to race\n\t\t * @returns {Promise} if input is non-empty, a promise that will settle\n\t\t * to the same outcome as the earliest input promise to settle. if empty\n\t\t * is empty, returns a promise that will never settle.\n\t\t */\n\t\tfunction race(promises) {\n\t\t\t// Sigh, race([]) is untestable unless we return *something*\n\t\t\t// that is recognizable without calling .then() on it.\n\t\t\tif(Object(promises) === promises && promises.length === 0) {\n\t\t\t\treturn never();\n\t\t\t}\n\n\t\t\tvar h = new DeferredHandler();\n\t\t\tfor(var i=0; i<promises.length; ++i) {\n\t\t\t\tgetHandler(promises[i]).when(noop, noop, void 0, h, h.resolve, h.reject);\n\t\t\t}\n\n\t\t\treturn new InternalPromise(h);\n\t\t}\n\n\t\t// Promise internals\n\n\t\t/**\n\t\t * InternalPromise represents a promise that is either already\n\t\t * fulfilled or reject, or is following another promise, based\n\t\t * on the provided handler.\n\t\t * @private\n\t\t * @param {object} handler\n\t\t * @constructor\n\t\t */\n\t\tfunction InternalPromise(handler) {\n\t\t\tthis._handler = handler;\n\t\t}\n\n\t\tInternalPromise.prototype = objectCreate(Promise.prototype);\n\n\t\t/**\n\t\t * Get an appropriate handler for x, checking for untrusted thenables\n\t\t * and promise graph cycles.\n\t\t * @private\n\t\t * @param {*} x\n\t\t * @param {object?} h optional handler to check for cycles\n\t\t * @returns {object} handler\n\t\t */\n\t\tfunction getHandler(x, h) {\n\t\t\tif(x instanceof Promise) {\n\t\t\t\treturn getHandlerChecked(x, h);\n\t\t\t}\n\t\t\treturn maybeThenable(x) ? getHandlerUntrusted(x) : new FulfilledHandler(x);\n\t\t}\n\n\t\t/**\n\t\t * Get an appropriate handler for x, which must be either a thenable\n\t\t * @param {object} x\n\t\t * @returns {object} handler\n\t\t */\n\t\tfunction getHandlerThenable(x) {\n\t\t\treturn x instanceof Promise ? x._handler.join() : getHandlerUntrusted(x);\n\t\t}\n\n\t\t/**\n\t\t * Get x's handler, checking for cycles\n\t\t * @param {Promise} x\n\t\t * @param {object?} h handler to check for cycles\n\t\t * @returns {object} handler\n\t\t */\n\t\tfunction getHandlerChecked(x, h) {\n\t\t\tvar xh = x._handler.join();\n\t\t\treturn h === xh ? promiseCycleHandler() : xh;\n\t\t}\n\n\t\t/**\n\t\t * Get a handler for potentially untrusted thenable x\n\t\t * @param {*} x\n\t\t * @returns {object} handler\n\t\t */\n\t\tfunction getHandlerUntrusted(x) {\n\t\t\ttry {\n\t\t\t\tvar untrustedThen = x.then;\n\t\t\t\treturn typeof untrustedThen === 'function'\n\t\t\t\t\t? new ThenableHandler(untrustedThen, x)\n\t\t\t\t\t: new FulfilledHandler(x);\n\t\t\t} catch(e) {\n\t\t\t\treturn new RejectedHandler(e);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Handler for a promise that is pending forever\n\t\t * @private\n\t\t * @constructor\n\t\t */\n\t\tfunction Handler() {}\n\n\t\tHandler.prototype.inspect = toPendingState;\n\t\tHandler.prototype.when = noop;\n\t\tHandler.prototype.resolve = noop;\n\t\tHandler.prototype.reject = noop;\n\t\tHandler.prototype.notify = noop;\n\t\tHandler.prototype.join = function() { return this; };\n\n\t\tHandler.prototype._env = environment.monitor || Promise;\n\t\tHandler.prototype._addTrace = noop;\n\t\tHandler.prototype._isMonitored = function() {\n\t\t\treturn typeof this._env.promiseMonitor !== 'undefined';\n\t\t};\n\n\t\t/**\n\t\t * Abstract base for handler that delegates to another handler\n\t\t * @private\n\t\t * @param {object} handler\n\t\t * @constructor\n\t\t */\n\t\tfunction DelegateHandler(handler) {\n\t\t\tthis.handler = handler;\n\t\t\tif(this._isMonitored()) {\n\t\t\t\tvar trace = this._env.promiseMonitor.captureStack();\n\t\t\t\tthis.trace = handler._addTrace(trace);\n\t\t\t}\n\t\t}\n\n\t\tDelegateHandler.prototype = objectCreate(Handler.prototype);\n\n\t\tDelegateHandler.prototype.join = function() {\n\t\t\treturn this.handler.join();\n\t\t};\n\n\t\tDelegateHandler.prototype.inspect = function() {\n\t\t\treturn this.handler.inspect();\n\t\t};\n\n\t\tDelegateHandler.prototype._addTrace = function(trace) {\n\t\t\treturn this.handler._addTrace(trace);\n\t\t};\n\n\t\t/**\n\t\t * Handler that manages a queue of consumers waiting on a pending promise\n\t\t * @private\n\t\t * @constructor\n\t\t */\n\t\tfunction DeferredHandler(receiver) {\n\t\t\tthis.consumers = [];\n\t\t\tthis.receiver = receiver;\n\t\t\tthis.handler = void 0;\n\t\t\tthis.resolved = false;\n\t\t\tif(this._isMonitored()) {\n\t\t\t\tthis.trace = this._env.promiseMonitor.captureStack();\n\t\t\t}\n\t\t}\n\n\t\tDeferredHandler.prototype = objectCreate(Handler.prototype);\n\n\t\tDeferredHandler.prototype.inspect = function() {\n\t\t\treturn this.resolved ? this.handler.join().inspect() : toPendingState();\n\t\t};\n\n\t\tDeferredHandler.prototype.resolve = function(x) {\n\t\t\tthis._join(getHandler(x, this));\n\t\t};\n\n\t\tDeferredHandler.prototype.reject = function(x) {\n\t\t\tthis._join(new RejectedHandler(x));\n\t\t};\n\n\t\tDeferredHandler.prototype.join = function() {\n\t\t\treturn this.resolved ? this.handler.join() : this;\n\t\t};\n\n\t\tDeferredHandler.prototype.run = function() {\n\t\t\tvar q = this.consumers;\n\t\t\tvar handler = this.handler = this.handler.join();\n\t\t\tthis.consumers = void 0;\n\n\t\t\tfor (var i = 0; i < q.length; i+=7) {\n\t\t\t\thandler.when(q[i], q[i+1], q[i+2], q[i+3], q[i+4], q[i+5], q[i+6]);\n\t\t\t}\n\t\t};\n\n\t\tDeferredHandler.prototype._join = function(handler) {\n\t\t\tif(this.resolved) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.resolved = true;\n\t\t\tthis.handler = handler;\n\t\t\ttasks.enqueue(this);\n\n\t\t\tif(this._isMonitored()) {\n\t\t\t\tthis.trace = handler._addTrace(this.trace);\n\t\t\t}\n\t\t};\n\n\t\tDeferredHandler.prototype.when = function(resolve, notify, t, receiver, f, r, u) {\n\t\t\tif(this.resolved) {\n\t\t\t\ttasks.enqueue(new RunHandlerTask(resolve, notify, t, receiver, f, r, u, this.handler.join()));\n\t\t\t} else {\n\t\t\t\tthis.consumers.push(resolve, notify, t, receiver, f, r, u);\n\t\t\t}\n\t\t};\n\n\t\tDeferredHandler.prototype.notify = function(x) {\n\t\t\tif(!this.resolved) {\n\t\t\t\ttasks.enqueue(new ProgressTask(this.consumers, x));\n\t\t\t}\n\t\t};\n\n\t\tDeferredHandler.prototype._addTrace = function(trace) {\n\t\t\treturn this.resolved ? this.handler._addTrace(trace) : trace;\n\t\t};\n\n\t\t/**\n\t\t * Wrap another handler and force it into a future stack\n\t\t * @private\n\t\t * @param {object} handler\n\t\t * @constructor\n\t\t */\n\t\tfunction AsyncHandler(handler) {\n\t\t\tDelegateHandler.call(this, handler);\n\t\t}\n\n\t\tAsyncHandler.prototype = objectCreate(DelegateHandler.prototype);\n\n\t\tAsyncHandler.prototype.when = function(resolve, notify, t, receiver, f, r, u) {\n\t\t\ttasks.enqueue(new RunHandlerTask(resolve, notify, t, receiver, f, r, u, this.join()));\n\t\t};\n\n\t\t/**\n\t\t * Handler that follows another handler, injecting a receiver\n\t\t * @private\n\t\t * @param {object} handler another handler to follow\n\t\t * @param {object=undefined} receiver\n\t\t * @constructor\n\t\t */\n\t\tfunction BoundHandler(handler, receiver) {\n\t\t\tDelegateHandler.call(this, handler);\n\t\t\tthis.receiver = receiver;\n\t\t}\n\n\t\tBoundHandler.prototype = objectCreate(DelegateHandler.prototype);\n\n\t\tBoundHandler.prototype.when = function(resolve, notify, t, receiver, f, r, u) {\n\t\t\t// Because handlers are allowed to be shared among promises,\n\t\t\t// each of which possibly having a different receiver, we have\n\t\t\t// to insert our own receiver into the chain if it has been set\n\t\t\t// so that callbacks (f, r, u) will be called using our receiver\n\t\t\tif(this.receiver !== void 0) {\n\t\t\t\treceiver = this.receiver;\n\t\t\t}\n\t\t\tthis.join().when(resolve, notify, t, receiver, f, r, u);\n\t\t};\n\n\t\t/**\n\t\t * Handler that wraps an untrusted thenable and assimilates it in a future stack\n\t\t * @private\n\t\t * @param {function} then\n\t\t * @param {{then: function}} thenable\n\t\t * @constructor\n\t\t */\n\t\tfunction ThenableHandler(then, thenable) {\n\t\t\tDeferredHandler.call(this);\n\t\t\tthis.assimilated = false;\n\t\t\tthis.untrustedThen = then;\n\t\t\tthis.thenable = thenable;\n\t\t}\n\n\t\tThenableHandler.prototype = objectCreate(DeferredHandler.prototype);\n\n\t\tThenableHandler.prototype.when = function(resolve, notify, t, receiver, f, r, u) {\n\t\t\tif(!this.assimilated) {\n\t\t\t\tthis.assimilated = true;\n\t\t\t\tthis._assimilate();\n\t\t\t}\n\t\t\tDeferredHandler.prototype.when.call(this, resolve, notify, t, receiver, f, r, u);\n\t\t};\n\n\t\tThenableHandler.prototype._assimilate = function() {\n\t\t\tvar h = this;\n\t\t\tthis._try(this.untrustedThen, this.thenable, _resolve, _reject, _notify);\n\n\t\t\tfunction _resolve(x) { h.resolve(x); }\n\t\t\tfunction _reject(x)  { h.reject(x); }\n\t\t\tfunction _notify(x)  { h.notify(x); }\n\t\t};\n\n\t\tThenableHandler.prototype._try = function(then, thenable, resolve, reject, notify) {\n\t\t\ttry {\n\t\t\t\tthen.call(thenable, resolve, reject, notify);\n\t\t\t} catch (e) {\n\t\t\t\treject(e);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Handler for a fulfilled promise\n\t\t * @private\n\t\t * @param {*} x fulfillment value\n\t\t * @constructor\n\t\t */\n\t\tfunction FulfilledHandler(x) {\n\t\t\tthis.value = x;\n\t\t}\n\n\t\tFulfilledHandler.prototype = objectCreate(Handler.prototype);\n\n\t\tFulfilledHandler.prototype.inspect = function() {\n\t\t\treturn toFulfilledState(this.value);\n\t\t};\n\n\t\tFulfilledHandler.prototype.when = function(resolve, notify, t, receiver, f) {\n\t\t\tvar x = typeof f === 'function'\n\t\t\t\t? tryCatchReject(f, this.value, receiver)\n\t\t\t\t: this.value;\n\n\t\t\tresolve.call(t, x);\n\t\t};\n\n\t\t/**\n\t\t * Handler for a rejected promise\n\t\t * @private\n\t\t * @param {*} x rejection reason\n\t\t * @constructor\n\t\t */\n\t\tfunction RejectedHandler(x) {\n\t\t\tthis.value = x;\n\t\t\tthis.observed = false;\n\n\t\t\tif(this._isMonitored()) {\n\t\t\t\tthis.key = this._env.promiseMonitor.startTrace(x);\n\t\t\t}\n\t\t}\n\n\t\tRejectedHandler.prototype = objectCreate(Handler.prototype);\n\n\t\tRejectedHandler.prototype.inspect = function() {\n\t\t\treturn toRejectedState(this.value);\n\t\t};\n\n\t\tRejectedHandler.prototype.when = function(resolve, notify, t, receiver, f, r) {\n\t\t\tif(this._isMonitored() && !this.observed) {\n\t\t\t\tthis._env.promiseMonitor.removeTrace(this.key);\n\t\t\t}\n\n\t\t\tthis.observed = true;\n\t\t\tvar x = typeof r === 'function'\n\t\t\t\t? tryCatchReject(r, this.value, receiver)\n\t\t\t\t: reject(this.value);\n\n\t\t\tresolve.call(t, x);\n\t\t};\n\n\t\tRejectedHandler.prototype._addTrace = function(trace) {\n\t\t\tif(!this.observed) {\n\t\t\t\tthis._env.promiseMonitor.updateTrace(this.key, trace);\n\t\t\t}\n\t\t};\n\n\t\t// Errors and singletons\n\n\t\tforeverPendingPromise = new InternalPromise(new Handler());\n\n\t\tfunction promiseCycleHandler() {\n\t\t\treturn new RejectedHandler(new TypeError('Promise cycle'));\n\t\t}\n\n\t\t// Snapshot states\n\n\t\t/**\n\t\t * Creates a fulfilled state snapshot\n\t\t * @private\n\t\t * @param {*} x any value\n\t\t * @returns {{state:'fulfilled',value:*}}\n\t\t */\n\t\tfunction toFulfilledState(x) {\n\t\t\treturn { state: 'fulfilled', value: x };\n\t\t}\n\n\t\t/**\n\t\t * Creates a rejected state snapshot\n\t\t * @private\n\t\t * @param {*} x any reason\n\t\t * @returns {{state:'rejected',reason:*}}\n\t\t */\n\t\tfunction toRejectedState(x) {\n\t\t\treturn { state: 'rejected', reason: x };\n\t\t}\n\n\t\t/**\n\t\t * Creates a pending state snapshot\n\t\t * @private\n\t\t * @returns {{state:'pending'}}\n\t\t */\n\t\tfunction toPendingState() {\n\t\t\treturn { state: 'pending' };\n\t\t}\n\n\t\t// Task runners\n\n\t\t/**\n\t\t * Run a single consumer\n\t\t * @private\n\t\t * @constructor\n\t\t */\n\t\tfunction RunHandlerTask(a, b, c, d, e, f, g, handler) {\n\t\t\tthis.a=a;this.b=b;this.c=c;this.d=d;this.e=e;this.f=f;this.g=g;\n\t\t\tthis.handler = handler;\n\t\t}\n\n\t\tRunHandlerTask.prototype.run = function() {\n\t\t\tthis.handler.when(this.a, this.b, this.c, this.d, this.e, this.f, this.g);\n\t\t};\n\n\t\t/**\n\t\t * Run a queue of progress handlers\n\t\t * @private\n\t\t * @constructor\n\t\t */\n\t\tfunction ProgressTask(q, value) {\n\t\t\tthis.q = q;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\tProgressTask.prototype.run = function() {\n\t\t\tvar q = this.q;\n\t\t\t// First progress handler is at index 1\n\t\t\tfor (var i = 1; i < q.length; i+=7) {\n\t\t\t\tthis._notify(q[i], q[i+1], q[i+2], q[i+5]);\n\t\t\t}\n\t\t};\n\n\t\tProgressTask.prototype._notify = function(notify, t, receiver, u) {\n\t\t\tvar x = typeof u === 'function'\n\t\t\t\t? tryCatchReturn(u, this.value, receiver)\n\t\t\t\t: this.value;\n\n\t\t\tnotify.call(t, x);\n\t\t};\n\n\t\t/**\n\t\t * @param {*} x\n\t\t * @returns {boolean} false iff x is guaranteed not to be a thenable\n\t\t */\n\t\tfunction maybeThenable(x) {\n\t\t\treturn (typeof x === 'object' || typeof x === 'function') && x !== null;\n\t\t}\n\n\t\t/**\n\t\t * Return f.call(thisArg, x), or if it throws return a rejected promise for\n\t\t * the thrown exception\n\t\t * @private\n\t\t */\n\t\tfunction tryCatchReject(f, x, thisArg) {\n\t\t\ttry {\n\t\t\t\treturn f.call(thisArg, x);\n\t\t\t} catch(e) {\n\t\t\t\treturn reject(e);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Return f.call(thisArg, x), or if it throws, *return* the exception\n\t\t * @private\n\t\t */\n\t\tfunction tryCatchReturn(f, x, thisArg) {\n\t\t\ttry {\n\t\t\t\treturn f.call(thisArg, x);\n\t\t\t} catch(e) {\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\n\t\tfunction noop() {}\n\n\t\treturn Promise;\n\t};\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n"],"mappings":"AAAA;AACA;AACA;;AAEC,WAASA,MAAM,EAAE;EAAE,YAAY;;EAChCA,MAAM,CAAC,YAAW;IAEjB,OAAO,SAASC,WAAWA,CAACC,WAAW,EAAE;MAExC,IAAIC,qBAAqB;MACzB,IAAIC,KAAK,GAAGF,WAAW,CAACG,SAAS;MAEjC,IAAIC,YAAY,GAAGC,MAAM,CAACC,MAAM,IAC/B,UAASC,KAAK,EAAE;QACf,SAASC,KAAKA,CAAA,EAAG,CAAC;QAClBA,KAAK,CAACC,SAAS,GAAGF,KAAK;QACvB,OAAO,IAAIC,KAAK,CAAC,CAAC;MACnB,CAAC;;MAEF;AACF;AACA;AACA;AACA;AACA;MACE,SAASE,OAAOA,CAACC,QAAQ,EAAE;QAC1B,IAAIC,IAAI,GAAG,IAAI;QACf,IAAI,CAACC,QAAQ,GAAG,IAAIC,eAAe,CAAC,CAAC;QAErCC,WAAW,CAACJ,QAAQ,EAAEK,cAAc,EAAEC,aAAa,EAAEC,aAAa,CAAC;;QAEnE;AACH;AACA;AACA;AACA;QACG,SAASF,cAAcA,CAAEG,CAAC,EAAE;UAC3BP,IAAI,CAACC,QAAQ,CAACO,OAAO,CAACD,CAAC,CAAC;QACzB;QACA;AACH;AACA;AACA;QACG,SAASF,aAAaA,CAAEI,MAAM,EAAE;UAC/BT,IAAI,CAACC,QAAQ,CAACS,MAAM,CAACD,MAAM,CAAC;QAC7B;;QAEA;AACH;AACA;AACA;QACG,SAASH,aAAaA,CAAEC,CAAC,EAAE;UAC1BP,IAAI,CAACC,QAAQ,CAACU,MAAM,CAACJ,CAAC,CAAC;QACxB;MACD;MAEA,SAASJ,WAAWA,CAACJ,QAAQ,EAAEK,cAAc,EAAEC,aAAa,EAAEC,aAAa,EAAE;QAC5E,IAAI;UACHP,QAAQ,CAACK,cAAc,EAAEC,aAAa,EAAEC,aAAa,CAAC;QACvD,CAAC,CAAC,OAAOM,CAAC,EAAE;UACXP,aAAa,CAACO,CAAC,CAAC;QACjB;MACD;;MAEA;;MAEAd,OAAO,CAACU,OAAO,GAAGA,OAAO;MACzBV,OAAO,CAACY,MAAM,GAAGA,MAAM;MACvBZ,OAAO,CAACe,KAAK,GAAGA,KAAK;MAErBf,OAAO,CAACgB,MAAM,GAAGC,KAAK;;MAEtB;AACF;AACA;AACA;AACA;AACA;MACE,SAASP,OAAOA,CAACD,CAAC,EAAE;QACnB,OAAOA,CAAC,YAAYT,OAAO,GAAGS,CAAC,GAC5B,IAAIS,eAAe,CAAC,IAAIC,YAAY,CAACC,UAAU,CAACX,CAAC,CAAC,CAAC,CAAC;MACxD;;MAEA;AACF;AACA;AACA;AACA;MACE,SAASG,MAAMA,CAACH,CAAC,EAAE;QAClB,OAAO,IAAIS,eAAe,CAAC,IAAIC,YAAY,CAAC,IAAIE,eAAe,CAACZ,CAAC,CAAC,CAAC,CAAC;MACrE;;MAEA;AACF;AACA;AACA;MACE,SAASM,KAAKA,CAAA,EAAG;QAChB,OAAOxB,qBAAqB,CAAC,CAAC;MAC/B;;MAEA;AACF;AACA;AACA;AACA;MACE,SAAS0B,KAAKA,CAAA,EAAG;QAChB,OAAO,IAAIC,eAAe,CAAC,IAAId,eAAe,CAAC,CAAC,CAAC;MAClD;;MAEA;;MAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACEJ,OAAO,CAACD,SAAS,CAACuB,IAAI,GAAG,UAASC,WAAW,EAAEC,UAAU,EAAEC,UAAU,EAAE;QACtE,IAAIC,IAAI,GAAG,IAAI,CAACvB,QAAQ;QACxB,IAAIwB,EAAE,GAAG,IAAIvB,eAAe,CAACsB,IAAI,CAACE,QAAQ,CAAC;QAC3CF,IAAI,CAACG,IAAI,CAACF,EAAE,CAACjB,OAAO,EAAEiB,EAAE,CAACd,MAAM,EAAEc,EAAE,EAAED,IAAI,CAACE,QAAQ,EAAEL,WAAW,EAAEC,UAAU,EAAEC,UAAU,CAAC;QAExF,OAAO,IAAIP,eAAe,CAACS,EAAE,CAAC;MAC/B,CAAC;;MAED;AACF;AACA;AACA;AACA;AACA;MACE3B,OAAO,CAACD,SAAS,CAAC,OAAO,CAAC,GAAGC,OAAO,CAACD,SAAS,CAAC+B,SAAS,GAAG,UAASN,UAAU,EAAE;QAC/E,OAAO,IAAI,CAACF,IAAI,CAAC,KAAK,CAAC,EAAEE,UAAU,CAAC;MACrC,CAAC;;MAED;AACF;AACA;AACA;AACA;AACA;AACA;MACExB,OAAO,CAACD,SAAS,CAACgC,YAAY,GAAG,UAASC,OAAO,EAAE;QAClD,OAAO,IAAId,eAAe,CAAC,IAAIe,YAAY,CAAC,IAAI,CAAC9B,QAAQ,EAAE6B,OAAO,CAAC,CAAC;MACrE,CAAC;;MAED;;MAEAhC,OAAO,CAACkC,GAAG,GAAGA,GAAG;MACjBlC,OAAO,CAACmC,IAAI,GAAGA,IAAI;;MAEnB;AACF;AACA;AACA;AACA;AACA;AACA;MACE,SAASD,GAAGA,CAACE,QAAQ,EAAE;QACtB;QACA,IAAInC,QAAQ,GAAG,IAAIG,eAAe,CAAC,CAAC;QACpC,IAAIiC,GAAG,GAAGD,QAAQ,CAACE,MAAM,KAAK,CAAC;QAC/B,IAAIC,OAAO,GAAGF,GAAG;QACjB,IAAIG,OAAO,GAAG,EAAE;QAChB,IAAIC,CAAC,EAAEhC,CAAC;QAER,KAAKgC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,GAAG,EAAE,EAAEI,CAAC,EAAE;UACzB,IAAIA,CAAC,IAAIL,QAAQ,EAAE;YAClB3B,CAAC,GAAG2B,QAAQ,CAACK,CAAC,CAAC;YACf,IAAIC,aAAa,CAACjC,CAAC,CAAC,EAAE;cACrBkC,UAAU,CAAC1C,QAAQ,EAAEuC,OAAO,EAAEI,kBAAkB,CAACnC,CAAC,CAAC,EAAEgC,CAAC,CAAC;YACxD,CAAC,MAAM;cACND,OAAO,CAACC,CAAC,CAAC,GAAGhC,CAAC;cACd,EAAE8B,OAAO;YACV;UACD,CAAC,MAAM;YACN,EAAEA,OAAO;UACV;QACD;QAEA,IAAGA,OAAO,KAAK,CAAC,EAAE;UACjBtC,QAAQ,CAACS,OAAO,CAAC8B,OAAO,CAAC;QAC1B;QAEA,OAAO,IAAItB,eAAe,CAACjB,QAAQ,CAAC;QAEpC,SAAS0C,UAAUA,CAAC1C,QAAQ,EAAEuC,OAAO,EAAEK,OAAO,EAAEJ,CAAC,EAAE;UAClDI,OAAO,CAAChB,IAAI,CAACiB,IAAI,EAAEA,IAAI,EAAE,KAAK,CAAC,EAAE7C,QAAQ,EAAE,UAASQ,CAAC,EAAE;YACtD+B,OAAO,CAACC,CAAC,CAAC,GAAGhC,CAAC;YACd,IAAG,EAAE8B,OAAO,KAAK,CAAC,EAAE;cACnB,IAAI,CAAC7B,OAAO,CAAC8B,OAAO,CAAC;YACtB;UACD,CAAC,EAAEvC,QAAQ,CAACW,MAAM,EAAEX,QAAQ,CAACY,MAAM,CAAC;QACrC;MACD;;MAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACE,SAASsB,IAAIA,CAACC,QAAQ,EAAE;QACvB;QACA;QACA,IAAGzC,MAAM,CAACyC,QAAQ,CAAC,KAAKA,QAAQ,IAAIA,QAAQ,CAACE,MAAM,KAAK,CAAC,EAAE;UAC1D,OAAOvB,KAAK,CAAC,CAAC;QACf;QAEA,IAAIgC,CAAC,GAAG,IAAI3C,eAAe,CAAC,CAAC;QAC7B,KAAI,IAAIqC,CAAC,GAAC,CAAC,EAAEA,CAAC,GAACL,QAAQ,CAACE,MAAM,EAAE,EAAEG,CAAC,EAAE;UACpCrB,UAAU,CAACgB,QAAQ,CAACK,CAAC,CAAC,CAAC,CAACZ,IAAI,CAACiB,IAAI,EAAEA,IAAI,EAAE,KAAK,CAAC,EAAEC,CAAC,EAAEA,CAAC,CAACrC,OAAO,EAAEqC,CAAC,CAACnC,MAAM,CAAC;QACzE;QAEA,OAAO,IAAIM,eAAe,CAAC6B,CAAC,CAAC;MAC9B;;MAEA;;MAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;MACE,SAAS7B,eAAeA,CAAC2B,OAAO,EAAE;QACjC,IAAI,CAAC1C,QAAQ,GAAG0C,OAAO;MACxB;MAEA3B,eAAe,CAACnB,SAAS,GAAGL,YAAY,CAACM,OAAO,CAACD,SAAS,CAAC;;MAE3D;AACF;AACA;AACA;AACA;AACA;AACA;AACA;MACE,SAASqB,UAAUA,CAACX,CAAC,EAAEsC,CAAC,EAAE;QACzB,IAAGtC,CAAC,YAAYT,OAAO,EAAE;UACxB,OAAOgD,iBAAiB,CAACvC,CAAC,EAAEsC,CAAC,CAAC;QAC/B;QACA,OAAOL,aAAa,CAACjC,CAAC,CAAC,GAAGwC,mBAAmB,CAACxC,CAAC,CAAC,GAAG,IAAIyC,gBAAgB,CAACzC,CAAC,CAAC;MAC3E;;MAEA;AACF;AACA;AACA;AACA;MACE,SAASmC,kBAAkBA,CAACnC,CAAC,EAAE;QAC9B,OAAOA,CAAC,YAAYT,OAAO,GAAGS,CAAC,CAACN,QAAQ,CAACgD,IAAI,CAAC,CAAC,GAAGF,mBAAmB,CAACxC,CAAC,CAAC;MACzE;;MAEA;AACF;AACA;AACA;AACA;AACA;MACE,SAASuC,iBAAiBA,CAACvC,CAAC,EAAEsC,CAAC,EAAE;QAChC,IAAIK,EAAE,GAAG3C,CAAC,CAACN,QAAQ,CAACgD,IAAI,CAAC,CAAC;QAC1B,OAAOJ,CAAC,KAAKK,EAAE,GAAGC,mBAAmB,CAAC,CAAC,GAAGD,EAAE;MAC7C;;MAEA;AACF;AACA;AACA;AACA;MACE,SAASH,mBAAmBA,CAACxC,CAAC,EAAE;QAC/B,IAAI;UACH,IAAI6C,aAAa,GAAG7C,CAAC,CAACa,IAAI;UAC1B,OAAO,OAAOgC,aAAa,KAAK,UAAU,GACvC,IAAIC,eAAe,CAACD,aAAa,EAAE7C,CAAC,CAAC,GACrC,IAAIyC,gBAAgB,CAACzC,CAAC,CAAC;QAC3B,CAAC,CAAC,OAAMK,CAAC,EAAE;UACV,OAAO,IAAIO,eAAe,CAACP,CAAC,CAAC;QAC9B;MACD;;MAEA;AACF;AACA;AACA;AACA;MACE,SAAS0C,OAAOA,CAAA,EAAG,CAAC;MAEpBA,OAAO,CAACzD,SAAS,CAAC0D,OAAO,GAAGC,cAAc;MAC1CF,OAAO,CAACzD,SAAS,CAAC8B,IAAI,GAAGiB,IAAI;MAC7BU,OAAO,CAACzD,SAAS,CAACW,OAAO,GAAGoC,IAAI;MAChCU,OAAO,CAACzD,SAAS,CAACa,MAAM,GAAGkC,IAAI;MAC/BU,OAAO,CAACzD,SAAS,CAACc,MAAM,GAAGiC,IAAI;MAC/BU,OAAO,CAACzD,SAAS,CAACoD,IAAI,GAAG,YAAW;QAAE,OAAO,IAAI;MAAE,CAAC;MAEpDK,OAAO,CAACzD,SAAS,CAAC4D,IAAI,GAAGrE,WAAW,CAACsE,OAAO,IAAI5D,OAAO;MACvDwD,OAAO,CAACzD,SAAS,CAAC8D,SAAS,GAAGf,IAAI;MAClCU,OAAO,CAACzD,SAAS,CAAC+D,YAAY,GAAG,YAAW;QAC3C,OAAO,OAAO,IAAI,CAACH,IAAI,CAACI,cAAc,KAAK,WAAW;MACvD,CAAC;;MAED;AACF;AACA;AACA;AACA;AACA;MACE,SAASC,eAAeA,CAACnB,OAAO,EAAE;QACjC,IAAI,CAACA,OAAO,GAAGA,OAAO;QACtB,IAAG,IAAI,CAACiB,YAAY,CAAC,CAAC,EAAE;UACvB,IAAIG,KAAK,GAAG,IAAI,CAACN,IAAI,CAACI,cAAc,CAACG,YAAY,CAAC,CAAC;UACnD,IAAI,CAACD,KAAK,GAAGpB,OAAO,CAACgB,SAAS,CAACI,KAAK,CAAC;QACtC;MACD;MAEAD,eAAe,CAACjE,SAAS,GAAGL,YAAY,CAAC8D,OAAO,CAACzD,SAAS,CAAC;MAE3DiE,eAAe,CAACjE,SAAS,CAACoD,IAAI,GAAG,YAAW;QAC3C,OAAO,IAAI,CAACN,OAAO,CAACM,IAAI,CAAC,CAAC;MAC3B,CAAC;MAEDa,eAAe,CAACjE,SAAS,CAAC0D,OAAO,GAAG,YAAW;QAC9C,OAAO,IAAI,CAACZ,OAAO,CAACY,OAAO,CAAC,CAAC;MAC9B,CAAC;MAEDO,eAAe,CAACjE,SAAS,CAAC8D,SAAS,GAAG,UAASI,KAAK,EAAE;QACrD,OAAO,IAAI,CAACpB,OAAO,CAACgB,SAAS,CAACI,KAAK,CAAC;MACrC,CAAC;;MAED;AACF;AACA;AACA;AACA;MACE,SAAS7D,eAAeA,CAACwB,QAAQ,EAAE;QAClC,IAAI,CAACuC,SAAS,GAAG,EAAE;QACnB,IAAI,CAACvC,QAAQ,GAAGA,QAAQ;QACxB,IAAI,CAACiB,OAAO,GAAG,KAAK,CAAC;QACrB,IAAI,CAACuB,QAAQ,GAAG,KAAK;QACrB,IAAG,IAAI,CAACN,YAAY,CAAC,CAAC,EAAE;UACvB,IAAI,CAACG,KAAK,GAAG,IAAI,CAACN,IAAI,CAACI,cAAc,CAACG,YAAY,CAAC,CAAC;QACrD;MACD;MAEA9D,eAAe,CAACL,SAAS,GAAGL,YAAY,CAAC8D,OAAO,CAACzD,SAAS,CAAC;MAE3DK,eAAe,CAACL,SAAS,CAAC0D,OAAO,GAAG,YAAW;QAC9C,OAAO,IAAI,CAACW,QAAQ,GAAG,IAAI,CAACvB,OAAO,CAACM,IAAI,CAAC,CAAC,CAACM,OAAO,CAAC,CAAC,GAAGC,cAAc,CAAC,CAAC;MACxE,CAAC;MAEDtD,eAAe,CAACL,SAAS,CAACW,OAAO,GAAG,UAASD,CAAC,EAAE;QAC/C,IAAI,CAAC4D,KAAK,CAACjD,UAAU,CAACX,CAAC,EAAE,IAAI,CAAC,CAAC;MAChC,CAAC;MAEDL,eAAe,CAACL,SAAS,CAACa,MAAM,GAAG,UAASH,CAAC,EAAE;QAC9C,IAAI,CAAC4D,KAAK,CAAC,IAAIhD,eAAe,CAACZ,CAAC,CAAC,CAAC;MACnC,CAAC;MAEDL,eAAe,CAACL,SAAS,CAACoD,IAAI,GAAG,YAAW;QAC3C,OAAO,IAAI,CAACiB,QAAQ,GAAG,IAAI,CAACvB,OAAO,CAACM,IAAI,CAAC,CAAC,GAAG,IAAI;MAClD,CAAC;MAED/C,eAAe,CAACL,SAAS,CAACuE,GAAG,GAAG,YAAW;QAC1C,IAAIC,CAAC,GAAG,IAAI,CAACJ,SAAS;QACtB,IAAItB,OAAO,GAAG,IAAI,CAACA,OAAO,GAAG,IAAI,CAACA,OAAO,CAACM,IAAI,CAAC,CAAC;QAChD,IAAI,CAACgB,SAAS,GAAG,KAAK,CAAC;QAEvB,KAAK,IAAI1B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8B,CAAC,CAACjC,MAAM,EAAEG,CAAC,IAAE,CAAC,EAAE;UACnCI,OAAO,CAAChB,IAAI,CAAC0C,CAAC,CAAC9B,CAAC,CAAC,EAAE8B,CAAC,CAAC9B,CAAC,GAAC,CAAC,CAAC,EAAE8B,CAAC,CAAC9B,CAAC,GAAC,CAAC,CAAC,EAAE8B,CAAC,CAAC9B,CAAC,GAAC,CAAC,CAAC,EAAE8B,CAAC,CAAC9B,CAAC,GAAC,CAAC,CAAC,EAAE8B,CAAC,CAAC9B,CAAC,GAAC,CAAC,CAAC,EAAE8B,CAAC,CAAC9B,CAAC,GAAC,CAAC,CAAC,CAAC;QACnE;MACD,CAAC;MAEDrC,eAAe,CAACL,SAAS,CAACsE,KAAK,GAAG,UAASxB,OAAO,EAAE;QACnD,IAAG,IAAI,CAACuB,QAAQ,EAAE;UACjB;QACD;QAEA,IAAI,CAACA,QAAQ,GAAG,IAAI;QACpB,IAAI,CAACvB,OAAO,GAAGA,OAAO;QACtBrD,KAAK,CAACgF,OAAO,CAAC,IAAI,CAAC;QAEnB,IAAG,IAAI,CAACV,YAAY,CAAC,CAAC,EAAE;UACvB,IAAI,CAACG,KAAK,GAAGpB,OAAO,CAACgB,SAAS,CAAC,IAAI,CAACI,KAAK,CAAC;QAC3C;MACD,CAAC;MAED7D,eAAe,CAACL,SAAS,CAAC8B,IAAI,GAAG,UAASnB,OAAO,EAAEG,MAAM,EAAE4D,CAAC,EAAE7C,QAAQ,EAAE8C,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAE;QAChF,IAAG,IAAI,CAACR,QAAQ,EAAE;UACjB5E,KAAK,CAACgF,OAAO,CAAC,IAAIK,cAAc,CAACnE,OAAO,EAAEG,MAAM,EAAE4D,CAAC,EAAE7C,QAAQ,EAAE8C,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAE,IAAI,CAAC/B,OAAO,CAACM,IAAI,CAAC,CAAC,CAAC,CAAC;QAC9F,CAAC,MAAM;UACN,IAAI,CAACgB,SAAS,CAACW,IAAI,CAACpE,OAAO,EAAEG,MAAM,EAAE4D,CAAC,EAAE7C,QAAQ,EAAE8C,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC;QAC3D;MACD,CAAC;MAEDxE,eAAe,CAACL,SAAS,CAACc,MAAM,GAAG,UAASJ,CAAC,EAAE;QAC9C,IAAG,CAAC,IAAI,CAAC2D,QAAQ,EAAE;UAClB5E,KAAK,CAACgF,OAAO,CAAC,IAAIO,YAAY,CAAC,IAAI,CAACZ,SAAS,EAAE1D,CAAC,CAAC,CAAC;QACnD;MACD,CAAC;MAEDL,eAAe,CAACL,SAAS,CAAC8D,SAAS,GAAG,UAASI,KAAK,EAAE;QACrD,OAAO,IAAI,CAACG,QAAQ,GAAG,IAAI,CAACvB,OAAO,CAACgB,SAAS,CAACI,KAAK,CAAC,GAAGA,KAAK;MAC7D,CAAC;;MAED;AACF;AACA;AACA;AACA;AACA;MACE,SAAS9C,YAAYA,CAAC0B,OAAO,EAAE;QAC9BmB,eAAe,CAACgB,IAAI,CAAC,IAAI,EAAEnC,OAAO,CAAC;MACpC;MAEA1B,YAAY,CAACpB,SAAS,GAAGL,YAAY,CAACsE,eAAe,CAACjE,SAAS,CAAC;MAEhEoB,YAAY,CAACpB,SAAS,CAAC8B,IAAI,GAAG,UAASnB,OAAO,EAAEG,MAAM,EAAE4D,CAAC,EAAE7C,QAAQ,EAAE8C,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAE;QAC7EpF,KAAK,CAACgF,OAAO,CAAC,IAAIK,cAAc,CAACnE,OAAO,EAAEG,MAAM,EAAE4D,CAAC,EAAE7C,QAAQ,EAAE8C,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAE,IAAI,CAACzB,IAAI,CAAC,CAAC,CAAC,CAAC;MACtF,CAAC;;MAED;AACF;AACA;AACA;AACA;AACA;AACA;MACE,SAASlB,YAAYA,CAACY,OAAO,EAAEjB,QAAQ,EAAE;QACxCoC,eAAe,CAACgB,IAAI,CAAC,IAAI,EAAEnC,OAAO,CAAC;QACnC,IAAI,CAACjB,QAAQ,GAAGA,QAAQ;MACzB;MAEAK,YAAY,CAAClC,SAAS,GAAGL,YAAY,CAACsE,eAAe,CAACjE,SAAS,CAAC;MAEhEkC,YAAY,CAAClC,SAAS,CAAC8B,IAAI,GAAG,UAASnB,OAAO,EAAEG,MAAM,EAAE4D,CAAC,EAAE7C,QAAQ,EAAE8C,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAE;QAC7E;QACA;QACA;QACA;QACA,IAAG,IAAI,CAAChD,QAAQ,KAAK,KAAK,CAAC,EAAE;UAC5BA,QAAQ,GAAG,IAAI,CAACA,QAAQ;QACzB;QACA,IAAI,CAACuB,IAAI,CAAC,CAAC,CAACtB,IAAI,CAACnB,OAAO,EAAEG,MAAM,EAAE4D,CAAC,EAAE7C,QAAQ,EAAE8C,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC;MACxD,CAAC;;MAED;AACF;AACA;AACA;AACA;AACA;AACA;MACE,SAASrB,eAAeA,CAACjC,IAAI,EAAE2D,QAAQ,EAAE;QACxC7E,eAAe,CAAC4E,IAAI,CAAC,IAAI,CAAC;QAC1B,IAAI,CAACE,WAAW,GAAG,KAAK;QACxB,IAAI,CAAC5B,aAAa,GAAGhC,IAAI;QACzB,IAAI,CAAC2D,QAAQ,GAAGA,QAAQ;MACzB;MAEA1B,eAAe,CAACxD,SAAS,GAAGL,YAAY,CAACU,eAAe,CAACL,SAAS,CAAC;MAEnEwD,eAAe,CAACxD,SAAS,CAAC8B,IAAI,GAAG,UAASnB,OAAO,EAAEG,MAAM,EAAE4D,CAAC,EAAE7C,QAAQ,EAAE8C,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAE;QAChF,IAAG,CAAC,IAAI,CAACM,WAAW,EAAE;UACrB,IAAI,CAACA,WAAW,GAAG,IAAI;UACvB,IAAI,CAACC,WAAW,CAAC,CAAC;QACnB;QACA/E,eAAe,CAACL,SAAS,CAAC8B,IAAI,CAACmD,IAAI,CAAC,IAAI,EAAEtE,OAAO,EAAEG,MAAM,EAAE4D,CAAC,EAAE7C,QAAQ,EAAE8C,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC;MACjF,CAAC;MAEDrB,eAAe,CAACxD,SAAS,CAACoF,WAAW,GAAG,YAAW;QAClD,IAAIpC,CAAC,GAAG,IAAI;QACZ,IAAI,CAACqC,IAAI,CAAC,IAAI,CAAC9B,aAAa,EAAE,IAAI,CAAC2B,QAAQ,EAAEI,QAAQ,EAAEC,OAAO,EAAEC,OAAO,CAAC;QAExE,SAASF,QAAQA,CAAC5E,CAAC,EAAE;UAAEsC,CAAC,CAACrC,OAAO,CAACD,CAAC,CAAC;QAAE;QACrC,SAAS6E,OAAOA,CAAC7E,CAAC,EAAG;UAAEsC,CAAC,CAACnC,MAAM,CAACH,CAAC,CAAC;QAAE;QACpC,SAAS8E,OAAOA,CAAC9E,CAAC,EAAG;UAAEsC,CAAC,CAAClC,MAAM,CAACJ,CAAC,CAAC;QAAE;MACrC,CAAC;MAED8C,eAAe,CAACxD,SAAS,CAACqF,IAAI,GAAG,UAAS9D,IAAI,EAAE2D,QAAQ,EAAEvE,OAAO,EAAEE,MAAM,EAAEC,MAAM,EAAE;QAClF,IAAI;UACHS,IAAI,CAAC0D,IAAI,CAACC,QAAQ,EAAEvE,OAAO,EAAEE,MAAM,EAAEC,MAAM,CAAC;QAC7C,CAAC,CAAC,OAAOC,CAAC,EAAE;UACXF,MAAM,CAACE,CAAC,CAAC;QACV;MACD,CAAC;;MAED;AACF;AACA;AACA;AACA;AACA;MACE,SAASoC,gBAAgBA,CAACzC,CAAC,EAAE;QAC5B,IAAI,CAAC+E,KAAK,GAAG/E,CAAC;MACf;MAEAyC,gBAAgB,CAACnD,SAAS,GAAGL,YAAY,CAAC8D,OAAO,CAACzD,SAAS,CAAC;MAE5DmD,gBAAgB,CAACnD,SAAS,CAAC0D,OAAO,GAAG,YAAW;QAC/C,OAAOgC,gBAAgB,CAAC,IAAI,CAACD,KAAK,CAAC;MACpC,CAAC;MAEDtC,gBAAgB,CAACnD,SAAS,CAAC8B,IAAI,GAAG,UAASnB,OAAO,EAAEG,MAAM,EAAE4D,CAAC,EAAE7C,QAAQ,EAAE8C,CAAC,EAAE;QAC3E,IAAIjE,CAAC,GAAG,OAAOiE,CAAC,KAAK,UAAU,GAC5BgB,cAAc,CAAChB,CAAC,EAAE,IAAI,CAACc,KAAK,EAAE5D,QAAQ,CAAC,GACvC,IAAI,CAAC4D,KAAK;QAEb9E,OAAO,CAACsE,IAAI,CAACP,CAAC,EAAEhE,CAAC,CAAC;MACnB,CAAC;;MAED;AACF;AACA;AACA;AACA;AACA;MACE,SAASY,eAAeA,CAACZ,CAAC,EAAE;QAC3B,IAAI,CAAC+E,KAAK,GAAG/E,CAAC;QACd,IAAI,CAACkF,QAAQ,GAAG,KAAK;QAErB,IAAG,IAAI,CAAC7B,YAAY,CAAC,CAAC,EAAE;UACvB,IAAI,CAAC8B,GAAG,GAAG,IAAI,CAACjC,IAAI,CAACI,cAAc,CAAC8B,UAAU,CAACpF,CAAC,CAAC;QAClD;MACD;MAEAY,eAAe,CAACtB,SAAS,GAAGL,YAAY,CAAC8D,OAAO,CAACzD,SAAS,CAAC;MAE3DsB,eAAe,CAACtB,SAAS,CAAC0D,OAAO,GAAG,YAAW;QAC9C,OAAOqC,eAAe,CAAC,IAAI,CAACN,KAAK,CAAC;MACnC,CAAC;MAEDnE,eAAe,CAACtB,SAAS,CAAC8B,IAAI,GAAG,UAASnB,OAAO,EAAEG,MAAM,EAAE4D,CAAC,EAAE7C,QAAQ,EAAE8C,CAAC,EAAEC,CAAC,EAAE;QAC7E,IAAG,IAAI,CAACb,YAAY,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC6B,QAAQ,EAAE;UACzC,IAAI,CAAChC,IAAI,CAACI,cAAc,CAACgC,WAAW,CAAC,IAAI,CAACH,GAAG,CAAC;QAC/C;QAEA,IAAI,CAACD,QAAQ,GAAG,IAAI;QACpB,IAAIlF,CAAC,GAAG,OAAOkE,CAAC,KAAK,UAAU,GAC5Be,cAAc,CAACf,CAAC,EAAE,IAAI,CAACa,KAAK,EAAE5D,QAAQ,CAAC,GACvChB,MAAM,CAAC,IAAI,CAAC4E,KAAK,CAAC;QAErB9E,OAAO,CAACsE,IAAI,CAACP,CAAC,EAAEhE,CAAC,CAAC;MACnB,CAAC;MAEDY,eAAe,CAACtB,SAAS,CAAC8D,SAAS,GAAG,UAASI,KAAK,EAAE;QACrD,IAAG,CAAC,IAAI,CAAC0B,QAAQ,EAAE;UAClB,IAAI,CAAChC,IAAI,CAACI,cAAc,CAACiC,WAAW,CAAC,IAAI,CAACJ,GAAG,EAAE3B,KAAK,CAAC;QACtD;MACD,CAAC;;MAED;;MAEA1E,qBAAqB,GAAG,IAAI2B,eAAe,CAAC,IAAIsC,OAAO,CAAC,CAAC,CAAC;MAE1D,SAASH,mBAAmBA,CAAA,EAAG;QAC9B,OAAO,IAAIhC,eAAe,CAAC,IAAI4E,SAAS,CAAC,eAAe,CAAC,CAAC;MAC3D;;MAEA;;MAEA;AACF;AACA;AACA;AACA;AACA;MACE,SAASR,gBAAgBA,CAAChF,CAAC,EAAE;QAC5B,OAAO;UAAEyF,KAAK,EAAE,WAAW;UAAEV,KAAK,EAAE/E;QAAE,CAAC;MACxC;;MAEA;AACF;AACA;AACA;AACA;AACA;MACE,SAASqF,eAAeA,CAACrF,CAAC,EAAE;QAC3B,OAAO;UAAEyF,KAAK,EAAE,UAAU;UAAEvF,MAAM,EAAEF;QAAE,CAAC;MACxC;;MAEA;AACF;AACA;AACA;AACA;MACE,SAASiD,cAAcA,CAAA,EAAG;QACzB,OAAO;UAAEwC,KAAK,EAAE;QAAU,CAAC;MAC5B;;MAEA;;MAEA;AACF;AACA;AACA;AACA;MACE,SAASrB,cAAcA,CAACsB,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAExF,CAAC,EAAE4D,CAAC,EAAE6B,CAAC,EAAE1D,OAAO,EAAE;QACrD,IAAI,CAACsD,CAAC,GAACA,CAAC;QAAC,IAAI,CAACC,CAAC,GAACA,CAAC;QAAC,IAAI,CAACC,CAAC,GAACA,CAAC;QAAC,IAAI,CAACC,CAAC,GAACA,CAAC;QAAC,IAAI,CAACxF,CAAC,GAACA,CAAC;QAAC,IAAI,CAAC4D,CAAC,GAACA,CAAC;QAAC,IAAI,CAAC6B,CAAC,GAACA,CAAC;QAC9D,IAAI,CAAC1D,OAAO,GAAGA,OAAO;MACvB;MAEAgC,cAAc,CAAC9E,SAAS,CAACuE,GAAG,GAAG,YAAW;QACzC,IAAI,CAACzB,OAAO,CAAChB,IAAI,CAAC,IAAI,CAACsE,CAAC,EAAE,IAAI,CAACC,CAAC,EAAE,IAAI,CAACC,CAAC,EAAE,IAAI,CAACC,CAAC,EAAE,IAAI,CAACxF,CAAC,EAAE,IAAI,CAAC4D,CAAC,EAAE,IAAI,CAAC6B,CAAC,CAAC;MAC1E,CAAC;;MAED;AACF;AACA;AACA;AACA;MACE,SAASxB,YAAYA,CAACR,CAAC,EAAEiB,KAAK,EAAE;QAC/B,IAAI,CAACjB,CAAC,GAAGA,CAAC;QACV,IAAI,CAACiB,KAAK,GAAGA,KAAK;MACnB;MAEAT,YAAY,CAAChF,SAAS,CAACuE,GAAG,GAAG,YAAW;QACvC,IAAIC,CAAC,GAAG,IAAI,CAACA,CAAC;QACd;QACA,KAAK,IAAI9B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8B,CAAC,CAACjC,MAAM,EAAEG,CAAC,IAAE,CAAC,EAAE;UACnC,IAAI,CAAC8C,OAAO,CAAChB,CAAC,CAAC9B,CAAC,CAAC,EAAE8B,CAAC,CAAC9B,CAAC,GAAC,CAAC,CAAC,EAAE8B,CAAC,CAAC9B,CAAC,GAAC,CAAC,CAAC,EAAE8B,CAAC,CAAC9B,CAAC,GAAC,CAAC,CAAC,CAAC;QAC3C;MACD,CAAC;MAEDsC,YAAY,CAAChF,SAAS,CAACwF,OAAO,GAAG,UAAS1E,MAAM,EAAE4D,CAAC,EAAE7C,QAAQ,EAAEgD,CAAC,EAAE;QACjE,IAAInE,CAAC,GAAG,OAAOmE,CAAC,KAAK,UAAU,GAC5B4B,cAAc,CAAC5B,CAAC,EAAE,IAAI,CAACY,KAAK,EAAE5D,QAAQ,CAAC,GACvC,IAAI,CAAC4D,KAAK;QAEb3E,MAAM,CAACmE,IAAI,CAACP,CAAC,EAAEhE,CAAC,CAAC;MAClB,CAAC;;MAED;AACF;AACA;AACA;MACE,SAASiC,aAAaA,CAACjC,CAAC,EAAE;QACzB,OAAO,CAAC,OAAOA,CAAC,KAAK,QAAQ,IAAI,OAAOA,CAAC,KAAK,UAAU,KAAKA,CAAC,KAAK,IAAI;MACxE;;MAEA;AACF;AACA;AACA;AACA;MACE,SAASiF,cAAcA,CAAChB,CAAC,EAAEjE,CAAC,EAAEuB,OAAO,EAAE;QACtC,IAAI;UACH,OAAO0C,CAAC,CAACM,IAAI,CAAChD,OAAO,EAAEvB,CAAC,CAAC;QAC1B,CAAC,CAAC,OAAMK,CAAC,EAAE;UACV,OAAOF,MAAM,CAACE,CAAC,CAAC;QACjB;MACD;;MAEA;AACF;AACA;AACA;MACE,SAAS0F,cAAcA,CAAC9B,CAAC,EAAEjE,CAAC,EAAEuB,OAAO,EAAE;QACtC,IAAI;UACH,OAAO0C,CAAC,CAACM,IAAI,CAAChD,OAAO,EAAEvB,CAAC,CAAC;QAC1B,CAAC,CAAC,OAAMK,CAAC,EAAE;UACV,OAAOA,CAAC;QACT;MACD;MAEA,SAASgC,IAAIA,CAAA,EAAG,CAAC;MAEjB,OAAO9C,OAAO;IACf,CAAC;EACF,CAAC,CAAC;AACF,CAAC,EAAC,OAAOZ,MAAM,KAAK,UAAU,IAAIA,MAAM,CAACqH,GAAG,GAAGrH,MAAM,GAAG,UAASsH,OAAO,EAAE;EAAEC,MAAM,CAACC,OAAO,GAAGF,OAAO,CAAC,CAAC;AAAE,CAAC,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}