{"ast":null,"code":"// Approach:\n//\n// 1. Get the minimatch set\n// 2. For each pattern in the set, PROCESS(pattern)\n// 3. Store matches per-set, then uniq them\n//\n// PROCESS(pattern)\n// Get the first [n] items from pattern that are all strings\n// Join these together.  This is PREFIX.\n//   If there is no more remaining, then stat(PREFIX) and\n//   add to matches if it succeeds.  END.\n// readdir(PREFIX) as ENTRIES\n//   If fails, END\n//   If pattern[n] is GLOBSTAR\n//     // handle the case where the globstar match is empty\n//     // by pruning it out, and testing the resulting pattern\n//     PROCESS(pattern[0..n] + pattern[n+1 .. $])\n//     // handle other cases.\n//     for ENTRY in ENTRIES (not dotfiles)\n//       // attach globstar + tail onto the entry\n//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $])\n//\n//   else // not globstar\n//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)\n//       Test ENTRY against pattern[n]\n//       If fails, continue\n//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])\n//\n// Caveat:\n//   Cache all stats and readdirs results to minimize syscall.  Since all\n//   we ever care about is existence and directory-ness, we can just keep\n//   `true` for files, and [children,...] for directories, or `false` for\n//   things that don't exist.\n\nmodule.exports = glob;\nvar fs = require(\"fs\"),\n  minimatch = require(\"minimatch\"),\n  Minimatch = minimatch.Minimatch,\n  inherits = require(\"inherits\"),\n  EE = require(\"events\").EventEmitter,\n  path = require(\"path\"),\n  isDir = {},\n  assert = require(\"assert\").ok;\nfunction glob(pattern, options, cb) {\n  if (typeof options === \"function\") cb = options, options = {};\n  if (!options) options = {};\n  if (typeof options === \"number\") {\n    deprecated();\n    return;\n  }\n  var g = new Glob(pattern, options, cb);\n  return g.sync ? g.found : g;\n}\nglob.fnmatch = deprecated;\nfunction deprecated() {\n  throw new Error(\"glob's interface has changed. Please see the docs.\");\n}\nglob.sync = globSync;\nfunction globSync(pattern, options) {\n  if (typeof options === \"number\") {\n    deprecated();\n    return;\n  }\n  options = options || {};\n  options.sync = true;\n  return glob(pattern, options);\n}\nthis._processingEmitQueue = false;\nglob.Glob = Glob;\ninherits(Glob, EE);\nfunction Glob(pattern, options, cb) {\n  if (!(this instanceof Glob)) {\n    return new Glob(pattern, options, cb);\n  }\n  if (typeof options === \"function\") {\n    cb = options;\n    options = null;\n  }\n  if (typeof cb === \"function\") {\n    this.on(\"error\", cb);\n    this.on(\"end\", function (matches) {\n      cb(null, matches);\n    });\n  }\n  options = options || {};\n  this._endEmitted = false;\n  this.EOF = {};\n  this._emitQueue = [];\n  this.paused = false;\n  this._processingEmitQueue = false;\n  this.maxDepth = options.maxDepth || 1000;\n  this.maxLength = options.maxLength || Infinity;\n  this.cache = options.cache || {};\n  this.statCache = options.statCache || {};\n  this.changedCwd = false;\n  var cwd = process.cwd();\n  if (!options.hasOwnProperty(\"cwd\")) this.cwd = cwd;else {\n    this.cwd = options.cwd;\n    this.changedCwd = path.resolve(options.cwd) !== cwd;\n  }\n  this.root = options.root || path.resolve(this.cwd, \"/\");\n  this.root = path.resolve(this.root);\n  if (process.platform === \"win32\") this.root = this.root.replace(/\\\\/g, \"/\");\n  this.nomount = !!options.nomount;\n  if (!pattern) {\n    throw new Error(\"must provide pattern\");\n  }\n\n  // base-matching: just use globstar for that.\n  if (options.matchBase && -1 === pattern.indexOf(\"/\")) {\n    if (options.noglobstar) {\n      throw new Error(\"base matching requires globstar\");\n    }\n    pattern = \"**/\" + pattern;\n  }\n  this.strict = options.strict !== false;\n  this.dot = !!options.dot;\n  this.mark = !!options.mark;\n  this.sync = !!options.sync;\n  this.nounique = !!options.nounique;\n  this.nonull = !!options.nonull;\n  this.nosort = !!options.nosort;\n  this.nocase = !!options.nocase;\n  this.stat = !!options.stat;\n  this.debug = !!options.debug || !!options.globDebug;\n  if (this.debug) this.log = console.error;\n  this.silent = !!options.silent;\n  var mm = this.minimatch = new Minimatch(pattern, options);\n  this.options = mm.options;\n  pattern = this.pattern = mm.pattern;\n  this.error = null;\n  this.aborted = false;\n\n  // list of all the patterns that ** has resolved do, so\n  // we can avoid visiting multiple times.\n  this._globstars = {};\n  EE.call(this);\n\n  // process each pattern in the minimatch set\n  var n = this.minimatch.set.length;\n\n  // The matches are stored as {<filename>: true,...} so that\n  // duplicates are automagically pruned.\n  // Later, we do an Object.keys() on these.\n  // Keep them as a list so we can fill in when nonull is set.\n  this.matches = new Array(n);\n  this.minimatch.set.forEach(iterator.bind(this));\n  function iterator(pattern, i, set) {\n    this._process(pattern, 0, i, function (er) {\n      if (er) this.emit(\"error\", er);\n      if (--n <= 0) this._finish();\n    });\n  }\n}\nGlob.prototype.log = function () {};\nGlob.prototype._finish = function () {\n  assert(this instanceof Glob);\n  var nou = this.nounique,\n    all = nou ? [] : {};\n  for (var i = 0, l = this.matches.length; i < l; i++) {\n    var matches = this.matches[i];\n    this.log(\"matches[%d] =\", i, matches);\n    // do like the shell, and spit out the literal glob\n    if (!matches) {\n      if (this.nonull) {\n        var literal = this.minimatch.globSet[i];\n        if (nou) all.push(literal);else all[literal] = true;\n      }\n    } else {\n      // had matches\n      var m = Object.keys(matches);\n      if (nou) all.push.apply(all, m);else m.forEach(function (m) {\n        all[m] = true;\n      });\n    }\n  }\n  if (!nou) all = Object.keys(all);\n  if (!this.nosort) {\n    all = all.sort(this.nocase ? alphasorti : alphasort);\n  }\n  if (this.mark) {\n    // at *some* point we statted all of these\n    all = all.map(this._mark, this);\n  }\n  this.log(\"emitting end\", all);\n  this.EOF = this.found = all;\n  this.emitMatch(this.EOF);\n};\nfunction alphasorti(a, b) {\n  a = a.toLowerCase();\n  b = b.toLowerCase();\n  return alphasort(a, b);\n}\nfunction alphasort(a, b) {\n  return a > b ? 1 : a < b ? -1 : 0;\n}\nGlob.prototype._mark = function (p) {\n  var c = this.cache[p];\n  var m = p;\n  if (c) {\n    var isDir = c === 2 || Array.isArray(c);\n    var slash = p.slice(-1) === '/';\n    if (isDir && !slash) m += '/';else if (!isDir && slash) m = m.slice(0, -1);\n    if (m !== p) {\n      this.statCache[m] = this.statCache[p];\n      this.cache[m] = this.cache[p];\n    }\n  }\n  return m;\n};\nGlob.prototype.abort = function () {\n  this.aborted = true;\n  this.emit(\"abort\");\n};\nGlob.prototype.pause = function () {\n  if (this.paused) return;\n  if (this.sync) this.emit(\"error\", new Error(\"Can't pause/resume sync glob\"));\n  this.paused = true;\n  this.emit(\"pause\");\n};\nGlob.prototype.resume = function () {\n  if (!this.paused) return;\n  if (this.sync) this.emit(\"error\", new Error(\"Can't pause/resume sync glob\"));\n  this.paused = false;\n  this.emit(\"resume\");\n  this._processEmitQueue();\n  //process.nextTick(this.emit.bind(this, \"resume\"))\n};\n\nGlob.prototype.emitMatch = function (m) {\n  this.log('emitMatch', m);\n  this._emitQueue.push(m);\n  this._processEmitQueue();\n};\nGlob.prototype._processEmitQueue = function (m) {\n  this.log(\"pEQ paused=%j processing=%j m=%j\", this.paused, this._processingEmitQueue, m);\n  var done = false;\n  while (!this._processingEmitQueue && !this.paused) {\n    this._processingEmitQueue = true;\n    var m = this._emitQueue.shift();\n    this.log(\">processEmitQueue\", m === this.EOF ? \":EOF:\" : m);\n    if (!m) {\n      this.log(\">processEmitQueue, falsey m\");\n      this._processingEmitQueue = false;\n      break;\n    }\n    if (m === this.EOF || !(this.mark && !this.stat)) {\n      this.log(\"peq: unmarked, or eof\");\n      next.call(this, 0, false);\n    } else if (this.statCache[m]) {\n      var sc = this.statCache[m];\n      var exists;\n      if (sc) exists = sc.isDirectory() ? 2 : 1;\n      this.log(\"peq: stat cached\");\n      next.call(this, exists, exists === 2);\n    } else {\n      this.log(\"peq: _stat, then next\");\n      this._stat(m, next);\n    }\n    function next(exists, isDir) {\n      this.log(\"next\", m, exists, isDir);\n      var ev = m === this.EOF ? \"end\" : \"match\";\n\n      // \"end\" can only happen once.\n      assert(!this._endEmitted);\n      if (ev === \"end\") this._endEmitted = true;\n      if (exists) {\n        // Doesn't mean it necessarily doesn't exist, it's possible\n        // we just didn't check because we don't care that much, or\n        // this is EOF anyway.\n        if (isDir && !m.match(/\\/$/)) {\n          m = m + \"/\";\n        } else if (!isDir && m.match(/\\/$/)) {\n          m = m.replace(/\\/+$/, \"\");\n        }\n      }\n      this.log(\"emit\", ev, m);\n      this.emit(ev, m);\n      this._processingEmitQueue = false;\n      if (done && m !== this.EOF && !this.paused) this._processEmitQueue();\n    }\n  }\n  done = true;\n};\nGlob.prototype._process = function (pattern, depth, index, cb_) {\n  assert(this instanceof Glob);\n  var cb = function cb(er, res) {\n    assert(this instanceof Glob);\n    if (this.paused) {\n      if (!this._processQueue) {\n        this._processQueue = [];\n        this.once(\"resume\", function () {\n          var q = this._processQueue;\n          this._processQueue = null;\n          q.forEach(function (cb) {\n            cb();\n          });\n        });\n      }\n      this._processQueue.push(cb_.bind(this, er, res));\n    } else {\n      cb_.call(this, er, res);\n    }\n  }.bind(this);\n  if (this.aborted) return cb();\n  if (depth > this.maxDepth) return cb();\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0;\n  while (typeof pattern[n] === \"string\") {\n    n++;\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // see if there's anything else\n  var prefix;\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      prefix = pattern.join(\"/\");\n      this._stat(prefix, function (exists, isDir) {\n        // either it's there, or it isn't.\n        // nothing more to do, either way.\n        if (exists) {\n          if (prefix && isAbsolute(prefix) && !this.nomount) {\n            if (prefix.charAt(0) === \"/\") {\n              prefix = path.join(this.root, prefix);\n            } else {\n              prefix = path.resolve(this.root, prefix);\n            }\n          }\n          if (process.platform === \"win32\") prefix = prefix.replace(/\\\\/g, \"/\");\n          this.matches[index] = this.matches[index] || {};\n          this.matches[index][prefix] = true;\n          this.emitMatch(prefix);\n        }\n        return cb();\n      });\n      return;\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null;\n      break;\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's \"absolute\" like /foo/bar,\n      // or \"relative\" like \"../baz\"\n      prefix = pattern.slice(0, n);\n      prefix = prefix.join(\"/\");\n      break;\n  }\n\n  // get the list of entries.\n  var read;\n  if (prefix === null) read = \".\";else if (isAbsolute(prefix) || isAbsolute(pattern.join(\"/\"))) {\n    if (!prefix || !isAbsolute(prefix)) {\n      prefix = path.join(\"/\", prefix);\n    }\n    read = prefix = path.resolve(prefix);\n\n    // if (process.platform === \"win32\")\n    //   read = prefix = prefix.replace(/^[a-zA-Z]:|\\\\/g, \"/\")\n\n    this.log('absolute: ', prefix, this.root, pattern, read);\n  } else {\n    read = prefix;\n  }\n  this.log('readdir(%j)', read, this.cwd, this.root);\n  return this._readdir(read, function (er, entries) {\n    if (er) {\n      // not a directory!\n      // this means that, whatever else comes after this, it can never match\n      return cb();\n    }\n\n    // globstar is special\n    if (pattern[n] === minimatch.GLOBSTAR) {\n      // test without the globstar, and with every child both below\n      // and replacing the globstar.\n      var s = [pattern.slice(0, n).concat(pattern.slice(n + 1))];\n      entries.forEach(function (e) {\n        if (e.charAt(0) === \".\" && !this.dot) return;\n        // instead of the globstar\n        s.push(pattern.slice(0, n).concat(e).concat(pattern.slice(n + 1)));\n        // below the globstar\n        s.push(pattern.slice(0, n).concat(e).concat(pattern.slice(n)));\n      }, this);\n      s = s.filter(function (pattern) {\n        var key = gsKey(pattern);\n        var seen = !this._globstars[key];\n        this._globstars[key] = true;\n        return seen;\n      }, this);\n      if (!s.length) return cb();\n\n      // now asyncForEach over this\n      var l = s.length,\n        errState = null;\n      s.forEach(function (gsPattern) {\n        this._process(gsPattern, depth + 1, index, function (er) {\n          if (errState) return;\n          if (er) return cb(errState = er);\n          if (--l <= 0) return cb();\n        });\n      }, this);\n      return;\n    }\n\n    // not a globstar\n    // It will only match dot entries if it starts with a dot, or if\n    // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n    var pn = pattern[n];\n    var rawGlob = pattern[n]._glob,\n      dotOk = this.dot || rawGlob.charAt(0) === \".\";\n    entries = entries.filter(function (e) {\n      return (e.charAt(0) !== \".\" || dotOk) && e.match(pattern[n]);\n    });\n\n    // If n === pattern.length - 1, then there's no need for the extra stat\n    // *unless* the user has specified \"mark\" or \"stat\" explicitly.\n    // We know that they exist, since the readdir returned them.\n    if (n === pattern.length - 1 && !this.mark && !this.stat) {\n      entries.forEach(function (e) {\n        if (prefix) {\n          if (prefix !== \"/\") e = prefix + \"/\" + e;else e = prefix + e;\n        }\n        if (e.charAt(0) === \"/\" && !this.nomount) {\n          e = path.join(this.root, e);\n        }\n        if (process.platform === \"win32\") e = e.replace(/\\\\/g, \"/\");\n        this.matches[index] = this.matches[index] || {};\n        this.matches[index][e] = true;\n        this.emitMatch(e);\n      }, this);\n      return cb.call(this);\n    }\n\n    // now test all the remaining entries as stand-ins for that part\n    // of the pattern.\n    var l = entries.length,\n      errState = null;\n    if (l === 0) return cb(); // no matches possible\n    entries.forEach(function (e) {\n      var p = pattern.slice(0, n).concat(e).concat(pattern.slice(n + 1));\n      this._process(p, depth + 1, index, function (er) {\n        if (errState) return;\n        if (er) return cb(errState = er);\n        if (--l === 0) return cb.call(this);\n      });\n    }, this);\n  });\n};\nfunction gsKey(pattern) {\n  return '**' + pattern.map(function (p) {\n    return p === minimatch.GLOBSTAR ? '**' : '' + p;\n  }).join('/');\n}\nGlob.prototype._stat = function (f, cb) {\n  assert(this instanceof Glob);\n  var abs = f;\n  if (f.charAt(0) === \"/\") {\n    abs = path.join(this.root, f);\n  } else if (this.changedCwd) {\n    abs = path.resolve(this.cwd, f);\n  }\n  if (f.length > this.maxLength) {\n    var er = new Error(\"Path name too long\");\n    er.code = \"ENAMETOOLONG\";\n    er.path = f;\n    return this._afterStat(f, abs, cb, er);\n  }\n  this.log('stat', [this.cwd, f, '=', abs]);\n  if (!this.stat && this.cache.hasOwnProperty(f)) {\n    var exists = this.cache[f],\n      isDir = exists && (Array.isArray(exists) || exists === 2);\n    if (this.sync) return cb.call(this, !!exists, isDir);\n    return process.nextTick(cb.bind(this, !!exists, isDir));\n  }\n  var stat = this.statCache[abs];\n  if (this.sync || stat) {\n    var er;\n    try {\n      stat = fs.statSync(abs);\n    } catch (e) {\n      er = e;\n    }\n    this._afterStat(f, abs, cb, er, stat);\n  } else {\n    fs.stat(abs, this._afterStat.bind(this, f, abs, cb));\n  }\n};\nGlob.prototype._afterStat = function (f, abs, cb, er, stat) {\n  var exists;\n  assert(this instanceof Glob);\n  if (abs.slice(-1) === \"/\" && stat && !stat.isDirectory()) {\n    this.log(\"should be ENOTDIR, fake it\");\n    er = new Error(\"ENOTDIR, not a directory '\" + abs + \"'\");\n    er.path = abs;\n    er.code = \"ENOTDIR\";\n    stat = null;\n  }\n  var emit = !this.statCache[abs];\n  this.statCache[abs] = stat;\n  if (er || !stat) {\n    exists = false;\n  } else {\n    exists = stat.isDirectory() ? 2 : 1;\n    if (emit) this.emit('stat', f, stat);\n  }\n  this.cache[f] = this.cache[f] || exists;\n  cb.call(this, !!exists, exists === 2);\n};\nGlob.prototype._readdir = function (f, cb) {\n  assert(this instanceof Glob);\n  var abs = f;\n  if (f.charAt(0) === \"/\") {\n    abs = path.join(this.root, f);\n  } else if (isAbsolute(f)) {\n    abs = f;\n  } else if (this.changedCwd) {\n    abs = path.resolve(this.cwd, f);\n  }\n  if (f.length > this.maxLength) {\n    var er = new Error(\"Path name too long\");\n    er.code = \"ENAMETOOLONG\";\n    er.path = f;\n    return this._afterReaddir(f, abs, cb, er);\n  }\n  this.log('readdir', [this.cwd, f, abs]);\n  if (this.cache.hasOwnProperty(f)) {\n    var c = this.cache[f];\n    if (Array.isArray(c)) {\n      if (this.sync) return cb.call(this, null, c);\n      return process.nextTick(cb.bind(this, null, c));\n    }\n    if (!c || c === 1) {\n      // either ENOENT or ENOTDIR\n      var code = c ? \"ENOTDIR\" : \"ENOENT\",\n        er = new Error((c ? \"Not a directory\" : \"Not found\") + \": \" + f);\n      er.path = f;\n      er.code = code;\n      this.log(f, er);\n      if (this.sync) return cb.call(this, er);\n      return process.nextTick(cb.bind(this, er));\n    }\n\n    // at this point, c === 2, meaning it's a dir, but we haven't\n    // had to read it yet, or c === true, meaning it's *something*\n    // but we don't have any idea what.  Need to read it, either way.\n  }\n\n  if (this.sync) {\n    var er, entries;\n    try {\n      entries = fs.readdirSync(abs);\n    } catch (e) {\n      er = e;\n    }\n    return this._afterReaddir(f, abs, cb, er, entries);\n  }\n  fs.readdir(abs, this._afterReaddir.bind(this, f, abs, cb));\n};\nGlob.prototype._afterReaddir = function (f, abs, cb, er, entries) {\n  assert(this instanceof Glob);\n  if (entries && !er) {\n    this.cache[f] = entries;\n    // if we haven't asked to stat everything for suresies, then just\n    // assume that everything in there exists, so we can avoid\n    // having to stat it a second time.  This also gets us one step\n    // further into ELOOP territory.\n    if (!this.mark && !this.stat) {\n      entries.forEach(function (e) {\n        if (f === \"/\") e = f + e;else e = f + \"/\" + e;\n        this.cache[e] = true;\n      }, this);\n    }\n    return cb.call(this, er, entries);\n  }\n\n  // now handle errors, and cache the information\n  if (er) switch (er.code) {\n    case \"ENOTDIR\":\n      // totally normal. means it *does* exist.\n      this.cache[f] = 1;\n      return cb.call(this, er);\n    case \"ENOENT\": // not terribly unusual\n    case \"ELOOP\":\n    case \"ENAMETOOLONG\":\n    case \"UNKNOWN\":\n      this.cache[f] = false;\n      return cb.call(this, er);\n    default:\n      // some unusual error.  Treat as failure.\n      this.cache[f] = false;\n      if (this.strict) this.emit(\"error\", er);\n      if (!this.silent) console.error(\"glob error\", er);\n      return cb.call(this, er);\n  }\n};\nvar isAbsolute = process.platform === \"win32\" ? absWin : absUnix;\nfunction absWin(p) {\n  if (absUnix(p)) return true;\n  // pull off the device/UNC bit from a windows path.\n  // from node's lib/path.js\n  var splitDeviceRe = /^([a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?([\\\\\\/])?([\\s\\S]*?)$/,\n    result = splitDeviceRe.exec(p),\n    device = result[1] || '',\n    isUnc = device && device.charAt(1) !== ':',\n    isAbsolute = !!result[2] || isUnc; // UNC paths are always absolute\n\n  return isAbsolute;\n}\nfunction absUnix(p) {\n  return p.charAt(0) === \"/\" || p === \"\";\n}","map":{"version":3,"names":["module","exports","glob","fs","require","minimatch","Minimatch","inherits","EE","EventEmitter","path","isDir","assert","ok","pattern","options","cb","deprecated","g","Glob","sync","found","fnmatch","Error","globSync","_processingEmitQueue","on","matches","_endEmitted","EOF","_emitQueue","paused","maxDepth","maxLength","Infinity","cache","statCache","changedCwd","cwd","process","hasOwnProperty","resolve","root","platform","replace","nomount","matchBase","indexOf","noglobstar","strict","dot","mark","nounique","nonull","nosort","nocase","stat","debug","globDebug","log","console","error","silent","mm","aborted","_globstars","call","n","set","length","Array","forEach","iterator","bind","i","_process","er","emit","_finish","prototype","nou","all","l","literal","globSet","push","m","Object","keys","apply","sort","alphasorti","alphasort","map","_mark","emitMatch","a","b","toLowerCase","p","c","isArray","slash","slice","abort","pause","resume","_processEmitQueue","done","shift","next","sc","exists","isDirectory","_stat","ev","match","depth","index","cb_","res","_processQueue","once","q","prefix","join","isAbsolute","charAt","read","_readdir","entries","GLOBSTAR","s","concat","e","filter","key","gsKey","seen","errState","gsPattern","pn","rawGlob","_glob","dotOk","f","abs","code","_afterStat","nextTick","statSync","_afterReaddir","readdirSync","readdir","absWin","absUnix","splitDeviceRe","result","exec","device","isUnc"],"sources":["C:/Users/twotr/Desktop/College/vsCode/WorkHumanApplication/country-search/node_modules/scatter/node_modules/glob/glob.js"],"sourcesContent":["// Approach:\n//\n// 1. Get the minimatch set\n// 2. For each pattern in the set, PROCESS(pattern)\n// 3. Store matches per-set, then uniq them\n//\n// PROCESS(pattern)\n// Get the first [n] items from pattern that are all strings\n// Join these together.  This is PREFIX.\n//   If there is no more remaining, then stat(PREFIX) and\n//   add to matches if it succeeds.  END.\n// readdir(PREFIX) as ENTRIES\n//   If fails, END\n//   If pattern[n] is GLOBSTAR\n//     // handle the case where the globstar match is empty\n//     // by pruning it out, and testing the resulting pattern\n//     PROCESS(pattern[0..n] + pattern[n+1 .. $])\n//     // handle other cases.\n//     for ENTRY in ENTRIES (not dotfiles)\n//       // attach globstar + tail onto the entry\n//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $])\n//\n//   else // not globstar\n//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)\n//       Test ENTRY against pattern[n]\n//       If fails, continue\n//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])\n//\n// Caveat:\n//   Cache all stats and readdirs results to minimize syscall.  Since all\n//   we ever care about is existence and directory-ness, we can just keep\n//   `true` for files, and [children,...] for directories, or `false` for\n//   things that don't exist.\n\n\n\nmodule.exports = glob\n\nvar fs = require(\"fs\")\n, minimatch = require(\"minimatch\")\n, Minimatch = minimatch.Minimatch\n, inherits = require(\"inherits\")\n, EE = require(\"events\").EventEmitter\n, path = require(\"path\")\n, isDir = {}\n, assert = require(\"assert\").ok\n\nfunction glob (pattern, options, cb) {\n  if (typeof options === \"function\") cb = options, options = {}\n  if (!options) options = {}\n\n  if (typeof options === \"number\") {\n    deprecated()\n    return\n  }\n\n  var g = new Glob(pattern, options, cb)\n  return g.sync ? g.found : g\n}\n\nglob.fnmatch = deprecated\n\nfunction deprecated () {\n  throw new Error(\"glob's interface has changed. Please see the docs.\")\n}\n\nglob.sync = globSync\nfunction globSync (pattern, options) {\n  if (typeof options === \"number\") {\n    deprecated()\n    return\n  }\n\n  options = options || {}\n  options.sync = true\n  return glob(pattern, options)\n}\n\nthis._processingEmitQueue = false\n\nglob.Glob = Glob\ninherits(Glob, EE)\nfunction Glob (pattern, options, cb) {\n  if (!(this instanceof Glob)) {\n    return new Glob(pattern, options, cb)\n  }\n\n  if (typeof options === \"function\") {\n    cb = options\n    options = null\n  }\n\n  if (typeof cb === \"function\") {\n    this.on(\"error\", cb)\n    this.on(\"end\", function (matches) {\n      cb(null, matches)\n    })\n  }\n\n  options = options || {}\n\n  this._endEmitted = false\n  this.EOF = {}\n  this._emitQueue = []\n\n  this.paused = false\n  this._processingEmitQueue = false\n\n  this.maxDepth = options.maxDepth || 1000\n  this.maxLength = options.maxLength || Infinity\n  this.cache = options.cache || {}\n  this.statCache = options.statCache || {}\n\n  this.changedCwd = false\n  var cwd = process.cwd()\n  if (!options.hasOwnProperty(\"cwd\")) this.cwd = cwd\n  else {\n    this.cwd = options.cwd\n    this.changedCwd = path.resolve(options.cwd) !== cwd\n  }\n\n  this.root = options.root || path.resolve(this.cwd, \"/\")\n  this.root = path.resolve(this.root)\n  if (process.platform === \"win32\")\n    this.root = this.root.replace(/\\\\/g, \"/\")\n\n  this.nomount = !!options.nomount\n\n  if (!pattern) {\n    throw new Error(\"must provide pattern\")\n  }\n\n  // base-matching: just use globstar for that.\n  if (options.matchBase && -1 === pattern.indexOf(\"/\")) {\n    if (options.noglobstar) {\n      throw new Error(\"base matching requires globstar\")\n    }\n    pattern = \"**/\" + pattern\n  }\n\n  this.strict = options.strict !== false\n  this.dot = !!options.dot\n  this.mark = !!options.mark\n  this.sync = !!options.sync\n  this.nounique = !!options.nounique\n  this.nonull = !!options.nonull\n  this.nosort = !!options.nosort\n  this.nocase = !!options.nocase\n  this.stat = !!options.stat\n\n  this.debug = !!options.debug || !!options.globDebug\n  if (this.debug)\n    this.log = console.error\n\n  this.silent = !!options.silent\n\n  var mm = this.minimatch = new Minimatch(pattern, options)\n  this.options = mm.options\n  pattern = this.pattern = mm.pattern\n\n  this.error = null\n  this.aborted = false\n\n  // list of all the patterns that ** has resolved do, so\n  // we can avoid visiting multiple times.\n  this._globstars = {}\n\n  EE.call(this)\n\n  // process each pattern in the minimatch set\n  var n = this.minimatch.set.length\n\n  // The matches are stored as {<filename>: true,...} so that\n  // duplicates are automagically pruned.\n  // Later, we do an Object.keys() on these.\n  // Keep them as a list so we can fill in when nonull is set.\n  this.matches = new Array(n)\n\n  this.minimatch.set.forEach(iterator.bind(this))\n  function iterator (pattern, i, set) {\n    this._process(pattern, 0, i, function (er) {\n      if (er) this.emit(\"error\", er)\n      if (-- n <= 0) this._finish()\n    })\n  }\n}\n\nGlob.prototype.log = function () {}\n\nGlob.prototype._finish = function () {\n  assert(this instanceof Glob)\n\n  var nou = this.nounique\n  , all = nou ? [] : {}\n\n  for (var i = 0, l = this.matches.length; i < l; i ++) {\n    var matches = this.matches[i]\n    this.log(\"matches[%d] =\", i, matches)\n    // do like the shell, and spit out the literal glob\n    if (!matches) {\n      if (this.nonull) {\n        var literal = this.minimatch.globSet[i]\n        if (nou) all.push(literal)\n        else all[literal] = true\n      }\n    } else {\n      // had matches\n      var m = Object.keys(matches)\n      if (nou) all.push.apply(all, m)\n      else m.forEach(function (m) {\n        all[m] = true\n      })\n    }\n  }\n\n  if (!nou) all = Object.keys(all)\n\n  if (!this.nosort) {\n    all = all.sort(this.nocase ? alphasorti : alphasort)\n  }\n\n  if (this.mark) {\n    // at *some* point we statted all of these\n    all = all.map(this._mark, this)\n  }\n\n  this.log(\"emitting end\", all)\n\n  this.EOF = this.found = all\n  this.emitMatch(this.EOF)\n}\n\nfunction alphasorti (a, b) {\n  a = a.toLowerCase()\n  b = b.toLowerCase()\n  return alphasort(a, b)\n}\n\nfunction alphasort (a, b) {\n  return a > b ? 1 : a < b ? -1 : 0\n}\n\nGlob.prototype._mark = function (p) {\n  var c = this.cache[p]\n  var m = p\n  if (c) {\n    var isDir = c === 2 || Array.isArray(c)\n    var slash = p.slice(-1) === '/'\n\n    if (isDir && !slash)\n      m += '/'\n    else if (!isDir && slash)\n      m = m.slice(0, -1)\n\n    if (m !== p) {\n      this.statCache[m] = this.statCache[p]\n      this.cache[m] = this.cache[p]\n    }\n  }\n\n  return m\n}\n\nGlob.prototype.abort = function () {\n  this.aborted = true\n  this.emit(\"abort\")\n}\n\nGlob.prototype.pause = function () {\n  if (this.paused) return\n  if (this.sync)\n    this.emit(\"error\", new Error(\"Can't pause/resume sync glob\"))\n  this.paused = true\n  this.emit(\"pause\")\n}\n\nGlob.prototype.resume = function () {\n  if (!this.paused) return\n  if (this.sync)\n    this.emit(\"error\", new Error(\"Can't pause/resume sync glob\"))\n  this.paused = false\n  this.emit(\"resume\")\n  this._processEmitQueue()\n  //process.nextTick(this.emit.bind(this, \"resume\"))\n}\n\nGlob.prototype.emitMatch = function (m) {\n  this.log('emitMatch', m)\n  this._emitQueue.push(m)\n  this._processEmitQueue()\n}\n\nGlob.prototype._processEmitQueue = function (m) {\n  this.log(\"pEQ paused=%j processing=%j m=%j\", this.paused,\n           this._processingEmitQueue, m)\n  var done = false\n  while (!this._processingEmitQueue &&\n         !this.paused) {\n    this._processingEmitQueue = true\n    var m = this._emitQueue.shift()\n    this.log(\">processEmitQueue\", m === this.EOF ? \":EOF:\" : m)\n    if (!m) {\n      this.log(\">processEmitQueue, falsey m\")\n      this._processingEmitQueue = false\n      break\n    }\n\n    if (m === this.EOF || !(this.mark && !this.stat)) {\n      this.log(\"peq: unmarked, or eof\")\n      next.call(this, 0, false)\n    } else if (this.statCache[m]) {\n      var sc = this.statCache[m]\n      var exists\n      if (sc)\n        exists = sc.isDirectory() ? 2 : 1\n      this.log(\"peq: stat cached\")\n      next.call(this, exists, exists === 2)\n    } else {\n      this.log(\"peq: _stat, then next\")\n      this._stat(m, next)\n    }\n\n    function next(exists, isDir) {\n      this.log(\"next\", m, exists, isDir)\n      var ev = m === this.EOF ? \"end\" : \"match\"\n\n      // \"end\" can only happen once.\n      assert(!this._endEmitted)\n      if (ev === \"end\")\n        this._endEmitted = true\n\n      if (exists) {\n        // Doesn't mean it necessarily doesn't exist, it's possible\n        // we just didn't check because we don't care that much, or\n        // this is EOF anyway.\n        if (isDir && !m.match(/\\/$/)) {\n          m = m + \"/\"\n        } else if (!isDir && m.match(/\\/$/)) {\n          m = m.replace(/\\/+$/, \"\")\n        }\n      }\n      this.log(\"emit\", ev, m)\n      this.emit(ev, m)\n      this._processingEmitQueue = false\n      if (done && m !== this.EOF && !this.paused)\n        this._processEmitQueue()\n    }\n  }\n  done = true\n}\n\nGlob.prototype._process = function (pattern, depth, index, cb_) {\n  assert(this instanceof Glob)\n\n  var cb = function cb (er, res) {\n    assert(this instanceof Glob)\n    if (this.paused) {\n      if (!this._processQueue) {\n        this._processQueue = []\n        this.once(\"resume\", function () {\n          var q = this._processQueue\n          this._processQueue = null\n          q.forEach(function (cb) { cb() })\n        })\n      }\n      this._processQueue.push(cb_.bind(this, er, res))\n    } else {\n      cb_.call(this, er, res)\n    }\n  }.bind(this)\n\n  if (this.aborted) return cb()\n\n  if (depth > this.maxDepth) return cb()\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0\n  while (typeof pattern[n] === \"string\") {\n    n ++\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // see if there's anything else\n  var prefix\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      prefix = pattern.join(\"/\")\n      this._stat(prefix, function (exists, isDir) {\n        // either it's there, or it isn't.\n        // nothing more to do, either way.\n        if (exists) {\n          if (prefix && isAbsolute(prefix) && !this.nomount) {\n            if (prefix.charAt(0) === \"/\") {\n              prefix = path.join(this.root, prefix)\n            } else {\n              prefix = path.resolve(this.root, prefix)\n            }\n          }\n\n          if (process.platform === \"win32\")\n            prefix = prefix.replace(/\\\\/g, \"/\")\n\n          this.matches[index] = this.matches[index] || {}\n          this.matches[index][prefix] = true\n          this.emitMatch(prefix)\n        }\n        return cb()\n      })\n      return\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null\n      break\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's \"absolute\" like /foo/bar,\n      // or \"relative\" like \"../baz\"\n      prefix = pattern.slice(0, n)\n      prefix = prefix.join(\"/\")\n      break\n  }\n\n  // get the list of entries.\n  var read\n  if (prefix === null) read = \".\"\n  else if (isAbsolute(prefix) || isAbsolute(pattern.join(\"/\"))) {\n    if (!prefix || !isAbsolute(prefix)) {\n      prefix = path.join(\"/\", prefix)\n    }\n    read = prefix = path.resolve(prefix)\n\n    // if (process.platform === \"win32\")\n    //   read = prefix = prefix.replace(/^[a-zA-Z]:|\\\\/g, \"/\")\n\n    this.log('absolute: ', prefix, this.root, pattern, read)\n  } else {\n    read = prefix\n  }\n\n  this.log('readdir(%j)', read, this.cwd, this.root)\n\n  return this._readdir(read, function (er, entries) {\n    if (er) {\n      // not a directory!\n      // this means that, whatever else comes after this, it can never match\n      return cb()\n    }\n\n    // globstar is special\n    if (pattern[n] === minimatch.GLOBSTAR) {\n      // test without the globstar, and with every child both below\n      // and replacing the globstar.\n      var s = [ pattern.slice(0, n).concat(pattern.slice(n + 1)) ]\n      entries.forEach(function (e) {\n        if (e.charAt(0) === \".\" && !this.dot) return\n        // instead of the globstar\n        s.push(pattern.slice(0, n).concat(e).concat(pattern.slice(n + 1)))\n        // below the globstar\n        s.push(pattern.slice(0, n).concat(e).concat(pattern.slice(n)))\n      }, this)\n\n      s = s.filter(function (pattern) {\n        var key = gsKey(pattern)\n        var seen = !this._globstars[key]\n        this._globstars[key] = true\n        return seen\n      }, this)\n\n      if (!s.length)\n        return cb()\n\n      // now asyncForEach over this\n      var l = s.length\n      , errState = null\n      s.forEach(function (gsPattern) {\n        this._process(gsPattern, depth + 1, index, function (er) {\n          if (errState) return\n          if (er) return cb(errState = er)\n          if (--l <= 0) return cb()\n        })\n      }, this)\n\n      return\n    }\n\n    // not a globstar\n    // It will only match dot entries if it starts with a dot, or if\n    // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n    var pn = pattern[n]\n    var rawGlob = pattern[n]._glob\n    , dotOk = this.dot || rawGlob.charAt(0) === \".\"\n\n    entries = entries.filter(function (e) {\n      return (e.charAt(0) !== \".\" || dotOk) &&\n             e.match(pattern[n])\n    })\n\n    // If n === pattern.length - 1, then there's no need for the extra stat\n    // *unless* the user has specified \"mark\" or \"stat\" explicitly.\n    // We know that they exist, since the readdir returned them.\n    if (n === pattern.length - 1 &&\n        !this.mark &&\n        !this.stat) {\n      entries.forEach(function (e) {\n        if (prefix) {\n          if (prefix !== \"/\") e = prefix + \"/\" + e\n          else e = prefix + e\n        }\n        if (e.charAt(0) === \"/\" && !this.nomount) {\n          e = path.join(this.root, e)\n        }\n\n        if (process.platform === \"win32\")\n          e = e.replace(/\\\\/g, \"/\")\n\n        this.matches[index] = this.matches[index] || {}\n        this.matches[index][e] = true\n        this.emitMatch(e)\n      }, this)\n      return cb.call(this)\n    }\n\n\n    // now test all the remaining entries as stand-ins for that part\n    // of the pattern.\n    var l = entries.length\n    , errState = null\n    if (l === 0) return cb() // no matches possible\n    entries.forEach(function (e) {\n      var p = pattern.slice(0, n).concat(e).concat(pattern.slice(n + 1))\n      this._process(p, depth + 1, index, function (er) {\n        if (errState) return\n        if (er) return cb(errState = er)\n        if (--l === 0) return cb.call(this)\n      })\n    }, this)\n  })\n\n}\n\nfunction gsKey (pattern) {\n  return '**' + pattern.map(function (p) {\n    return (p === minimatch.GLOBSTAR) ? '**' : (''+p)\n  }).join('/')\n}\n\nGlob.prototype._stat = function (f, cb) {\n  assert(this instanceof Glob)\n  var abs = f\n  if (f.charAt(0) === \"/\") {\n    abs = path.join(this.root, f)\n  } else if (this.changedCwd) {\n    abs = path.resolve(this.cwd, f)\n  }\n\n  if (f.length > this.maxLength) {\n    var er = new Error(\"Path name too long\")\n    er.code = \"ENAMETOOLONG\"\n    er.path = f\n    return this._afterStat(f, abs, cb, er)\n  }\n\n  this.log('stat', [this.cwd, f, '=', abs])\n\n  if (!this.stat && this.cache.hasOwnProperty(f)) {\n    var exists = this.cache[f]\n    , isDir = exists && (Array.isArray(exists) || exists === 2)\n    if (this.sync) return cb.call(this, !!exists, isDir)\n    return process.nextTick(cb.bind(this, !!exists, isDir))\n  }\n\n  var stat = this.statCache[abs]\n  if (this.sync || stat) {\n    var er\n    try {\n      stat = fs.statSync(abs)\n    } catch (e) {\n      er = e\n    }\n    this._afterStat(f, abs, cb, er, stat)\n  } else {\n    fs.stat(abs, this._afterStat.bind(this, f, abs, cb))\n  }\n}\n\nGlob.prototype._afterStat = function (f, abs, cb, er, stat) {\n  var exists\n  assert(this instanceof Glob)\n\n  if (abs.slice(-1) === \"/\" && stat && !stat.isDirectory()) {\n    this.log(\"should be ENOTDIR, fake it\")\n\n    er = new Error(\"ENOTDIR, not a directory '\" + abs + \"'\")\n    er.path = abs\n    er.code = \"ENOTDIR\"\n    stat = null\n  }\n\n  var emit = !this.statCache[abs]\n  this.statCache[abs] = stat\n\n  if (er || !stat) {\n    exists = false\n  } else {\n    exists = stat.isDirectory() ? 2 : 1\n    if (emit)\n      this.emit('stat', f, stat)\n  }\n  this.cache[f] = this.cache[f] || exists\n  cb.call(this, !!exists, exists === 2)\n}\n\nGlob.prototype._readdir = function (f, cb) {\n  assert(this instanceof Glob)\n  var abs = f\n  if (f.charAt(0) === \"/\") {\n    abs = path.join(this.root, f)\n  } else if (isAbsolute(f)) {\n    abs = f\n  } else if (this.changedCwd) {\n    abs = path.resolve(this.cwd, f)\n  }\n\n  if (f.length > this.maxLength) {\n    var er = new Error(\"Path name too long\")\n    er.code = \"ENAMETOOLONG\"\n    er.path = f\n    return this._afterReaddir(f, abs, cb, er)\n  }\n\n  this.log('readdir', [this.cwd, f, abs])\n  if (this.cache.hasOwnProperty(f)) {\n    var c = this.cache[f]\n    if (Array.isArray(c)) {\n      if (this.sync) return cb.call(this, null, c)\n      return process.nextTick(cb.bind(this, null, c))\n    }\n\n    if (!c || c === 1) {\n      // either ENOENT or ENOTDIR\n      var code = c ? \"ENOTDIR\" : \"ENOENT\"\n      , er = new Error((c ? \"Not a directory\" : \"Not found\") + \": \" + f)\n      er.path = f\n      er.code = code\n      this.log(f, er)\n      if (this.sync) return cb.call(this, er)\n      return process.nextTick(cb.bind(this, er))\n    }\n\n    // at this point, c === 2, meaning it's a dir, but we haven't\n    // had to read it yet, or c === true, meaning it's *something*\n    // but we don't have any idea what.  Need to read it, either way.\n  }\n\n  if (this.sync) {\n    var er, entries\n    try {\n      entries = fs.readdirSync(abs)\n    } catch (e) {\n      er = e\n    }\n    return this._afterReaddir(f, abs, cb, er, entries)\n  }\n\n  fs.readdir(abs, this._afterReaddir.bind(this, f, abs, cb))\n}\n\nGlob.prototype._afterReaddir = function (f, abs, cb, er, entries) {\n  assert(this instanceof Glob)\n  if (entries && !er) {\n    this.cache[f] = entries\n    // if we haven't asked to stat everything for suresies, then just\n    // assume that everything in there exists, so we can avoid\n    // having to stat it a second time.  This also gets us one step\n    // further into ELOOP territory.\n    if (!this.mark && !this.stat) {\n      entries.forEach(function (e) {\n        if (f === \"/\") e = f + e\n        else e = f + \"/\" + e\n        this.cache[e] = true\n      }, this)\n    }\n\n    return cb.call(this, er, entries)\n  }\n\n  // now handle errors, and cache the information\n  if (er) switch (er.code) {\n    case \"ENOTDIR\": // totally normal. means it *does* exist.\n      this.cache[f] = 1\n      return cb.call(this, er)\n    case \"ENOENT\": // not terribly unusual\n    case \"ELOOP\":\n    case \"ENAMETOOLONG\":\n    case \"UNKNOWN\":\n      this.cache[f] = false\n      return cb.call(this, er)\n    default: // some unusual error.  Treat as failure.\n      this.cache[f] = false\n      if (this.strict) this.emit(\"error\", er)\n      if (!this.silent) console.error(\"glob error\", er)\n      return cb.call(this, er)\n  }\n}\n\nvar isAbsolute = process.platform === \"win32\" ? absWin : absUnix\n\nfunction absWin (p) {\n  if (absUnix(p)) return true\n  // pull off the device/UNC bit from a windows path.\n  // from node's lib/path.js\n  var splitDeviceRe =\n      /^([a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?([\\\\\\/])?([\\s\\S]*?)$/\n    , result = splitDeviceRe.exec(p)\n    , device = result[1] || ''\n    , isUnc = device && device.charAt(1) !== ':'\n    , isAbsolute = !!result[2] || isUnc // UNC paths are always absolute\n\n  return isAbsolute\n}\n\nfunction absUnix (p) {\n  return p.charAt(0) === \"/\" || p === \"\"\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}