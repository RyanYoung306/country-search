{"ast":null,"code":"/** @license MIT License (c) copyright 2010-2014 original author or authors */\n\n/**\n * A lightweight CommonJS Promises/A and when() implementation\n * when is part of the cujoJS family of libraries (http://cujojs.com/)\n * @author Brian Cavalier\n * @author John Hann\n * @version 3.0.1\n */\n(function (define) {\n  'use strict';\n\n  define(function (require) {\n    var timer = require('./lib/timer');\n    var timed = require('./lib/timed');\n    var array = require('./lib/array');\n    var flow = require('./lib/flow');\n    var inspect = require('./lib/inspect');\n    var generate = require('./lib/iterate');\n    var progress = require('./lib/progress');\n    var withThis = require('./lib/with');\n    var Promise = require('./lib/Promise');\n    Promise = [array, flow, generate, progress, inspect, withThis].reduceRight(function (Promise, feature) {\n      return feature(Promise);\n    }, timed(timer.set, timer.clear, Promise));\n    var resolve = Promise.resolve;\n    var slice = Array.prototype.slice;\n\n    // Public API\n\n    when.promise = promise; // Create a pending promise\n    when.resolve = Promise.resolve; // Create a resolved promise\n    when.reject = Promise.reject; // Create a rejected promise\n\n    when.lift = lift; // lift a function to return promises\n    when['try'] = tryCall; // call a function and return a promise\n    when.attempt = tryCall; // alias for when.try\n\n    when.iterate = Promise.iterate; // Generate a stream of promises\n    when.unfold = Promise.unfold; // Generate a stream of promises\n\n    when.join = join; // Join 2 or more promises\n\n    when.all = all; // Resolve a list of promises\n    when.settle = settle; // Settle a list of promises\n\n    when.any = lift(Promise.any); // One-winner race\n    when.some = lift(Promise.some); // Multi-winner race\n\n    when.map = map; // Array.map() for promises\n    when.reduce = reduce; // Array.reduce() for promises\n    when.reduceRight = reduceRight; // Array.reduceRight() for promises\n\n    when.isPromiseLike = isPromiseLike; // Is something promise-like, aka thenable\n\n    when.Promise = Promise; // Promise constructor\n    when.defer = defer; // Create a {promise, resolve, reject} tuple\n\n    /**\n     * When x, which may be a promise, thenable, or non-promise value,\n     *\n     * @param {*} x\n     * @param {function?} onFulfilled callback to be called when x is\n     *   successfully fulfilled.  If promiseOrValue is an immediate value, callback\n     *   will be invoked immediately.\n     * @param {function?} onRejected callback to be called when x is\n     *   rejected.\n     * @param {function?} onProgress callback to be called when progress updates\n     *   are issued for x.\n     * @returns {Promise} a new promise that will fulfill with the return\n     *   value of callback or errback or the completion value of promiseOrValue if\n     *   callback and/or errback is not supplied.\n     */\n    function when(x, onFulfilled, onRejected, onProgress) {\n      var p = resolve(x);\n      return arguments.length < 2 ? p : p.then(onFulfilled, onRejected, onProgress);\n    }\n\n    /**\n     * Creates a new promise whose fate is determined by resolver.\n     * @param {function} resolver function(resolve, reject, notify)\n     * @returns {Promise} promise whose fate is determine by resolver\n     */\n    function promise(resolver) {\n      return new Promise(resolver);\n    }\n\n    /**\n     * Lift the supplied function, creating a version of f that returns\n     * promises, and accepts promises as arguments.\n     * @param {function} f\n     * @returns {Function} version of f that returns promises\n     */\n    function lift(f) {\n      return function () {\n        return _apply(f, this, slice.call(arguments));\n      };\n    }\n\n    /**\n     * Call f in a future turn, with the supplied args, and return a promise\n     * for the result.\n     * @param {function} f\n     * @returns {Promise}\n     */\n    function tryCall(f /*, args... */) {\n      /*jshint validthis:true */\n      return _apply(f, this, slice.call(arguments, 1));\n    }\n\n    /**\n     * try/lift helper that allows specifying thisArg\n     * @private\n     */\n    function _apply(func, thisArg, args) {\n      return Promise.all(args).then(function (args) {\n        return func.apply(thisArg, args);\n      });\n    }\n\n    /**\n     * Creates a {promise, resolver} pair, either or both of which\n     * may be given out safely to consumers.\n     * @return {{promise: Promise, resolve: function, reject: function, notify: function}}\n     */\n    function defer() {\n      return new Deferred();\n    }\n    function Deferred() {\n      var p = Promise._defer();\n      function resolve(x) {\n        p._handler.resolve(x);\n      }\n      function reject(x) {\n        p._handler.reject(x);\n      }\n      function notify(x) {\n        p._handler.notify(x);\n      }\n      this.promise = p;\n      this.resolve = resolve;\n      this.reject = reject;\n      this.notify = notify;\n      this.resolver = {\n        resolve: resolve,\n        reject: reject,\n        notify: notify\n      };\n    }\n\n    /**\n     * Determines if x is promise-like, i.e. a thenable object\n     * NOTE: Will return true for *any thenable object*, and isn't truly\n     * safe, since it may attempt to access the `then` property of x (i.e.\n     *  clever/malicious getters may do weird things)\n     * @param {*} x anything\n     * @returns {boolean} true if x is promise-like\n     */\n    function isPromiseLike(x) {\n      return x && typeof x.then === 'function';\n    }\n\n    /**\n     * Return a promise that will resolve only once all the supplied arguments\n     * have resolved. The resolution value of the returned promise will be an array\n     * containing the resolution values of each of the arguments.\n     * @param {...*} arguments may be a mix of promises and values\n     * @returns {Promise}\n     */\n    function join( /* ...promises */\n    ) {\n      return Promise.all(arguments);\n    }\n\n    /**\n     * Return a promise that will fulfill once all input promises have\n     * fulfilled, or reject when any one input promise rejects.\n     * @param {array|Promise} promises array (or promise for an array) of promises\n     * @returns {Promise}\n     */\n    function all(promises) {\n      return when(promises, Promise.all);\n    }\n\n    /**\n     * Return a promise that will always fulfill with an array containing\n     * the outcome states of all input promises.  The returned promise\n     * will only reject if `promises` itself is a rejected promise.\n     * @param {array|Promise} promises array (or promise for an array) of promises\n     * @returns {Promise}\n     */\n    function settle(promises) {\n      return when(promises, Promise.settle);\n    }\n\n    /**\n     * Promise-aware array map function, similar to `Array.prototype.map()`,\n     * but input array may contain promises or values.\n     * @param {Array|Promise} promises array of anything, may contain promises and values\n     * @param {function} mapFunc map function which may return a promise or value\n     * @returns {Promise} promise that will fulfill with an array of mapped values\n     *  or reject if any input promise rejects.\n     */\n    function map(promises, mapFunc) {\n      return when(promises, function (promises) {\n        return Promise.map(promises, mapFunc);\n      });\n    }\n\n    /**\n     * Traditional reduce function, similar to `Array.prototype.reduce()`, but\n     * input may contain promises and/or values, and reduceFunc\n     * may return either a value or a promise, *and* initialValue may\n     * be a promise for the starting value.\n     *\n     * @param {Array|Promise} promises array or promise for an array of anything,\n     *      may contain a mix of promises and values.\n     * @param {function} f reduce function reduce(currentValue, nextValue, index)\n     * @returns {Promise} that will resolve to the final reduced value\n     */\n    function reduce(promises, f /*, initialValue */) {\n      /*jshint unused:false*/\n      var args = slice.call(arguments, 1);\n      return when(promises, function (array) {\n        args.unshift(array);\n        return Promise.reduce.apply(Promise, args);\n      });\n    }\n\n    /**\n     * Traditional reduce function, similar to `Array.prototype.reduceRight()`, but\n     * input may contain promises and/or values, and reduceFunc\n     * may return either a value or a promise, *and* initialValue may\n     * be a promise for the starting value.\n     *\n     * @param {Array|Promise} promises array or promise for an array of anything,\n     *      may contain a mix of promises and values.\n     * @param {function} f reduce function reduce(currentValue, nextValue, index)\n     * @returns {Promise} that will resolve to the final reduced value\n     */\n    function reduceRight(promises, f /*, initialValue */) {\n      /*jshint unused:false*/\n      var args = slice.call(arguments, 1);\n      return when(promises, function (array) {\n        args.unshift(array);\n        return Promise.reduceRight.apply(Promise, args);\n      });\n    }\n    return when;\n  });\n})(typeof define === 'function' && define.amd ? define : function (factory) {\n  module.exports = factory(require);\n});","map":{"version":3,"names":["define","require","timer","timed","array","flow","inspect","generate","progress","withThis","Promise","reduceRight","feature","set","clear","resolve","slice","Array","prototype","when","promise","reject","lift","tryCall","attempt","iterate","unfold","join","all","settle","any","some","map","reduce","isPromiseLike","defer","x","onFulfilled","onRejected","onProgress","p","arguments","length","then","resolver","f","_apply","call","func","thisArg","args","apply","Deferred","_defer","_handler","notify","promises","mapFunc","unshift","amd","factory","module","exports"],"sources":["C:/Users/twotr/Desktop/College/vsCode/WorkHumanApplication/country-search/node_modules/scatter/node_modules/when/when.js"],"sourcesContent":["/** @license MIT License (c) copyright 2010-2014 original author or authors */\n\n/**\n * A lightweight CommonJS Promises/A and when() implementation\n * when is part of the cujoJS family of libraries (http://cujojs.com/)\n * @author Brian Cavalier\n * @author John Hann\n * @version 3.0.1\n */\n(function(define) { 'use strict';\ndefine(function (require) {\n\n\tvar timer = require('./lib/timer');\n\tvar timed = require('./lib/timed');\n\tvar array = require('./lib/array');\n\tvar flow = require('./lib/flow');\n\tvar inspect = require('./lib/inspect');\n\tvar generate = require('./lib/iterate');\n\tvar progress = require('./lib/progress');\n\tvar withThis = require('./lib/with');\n\n\tvar Promise = require('./lib/Promise');\n\tPromise = [array, flow, generate, progress, inspect, withThis]\n\t\t.reduceRight(function(Promise, feature) {\n\t\t\treturn feature(Promise);\n\t\t}, timed(timer.set, timer.clear, Promise));\n\n\tvar resolve = Promise.resolve;\n\tvar slice = Array.prototype.slice;\n\n\t// Public API\n\n\twhen.promise     = promise;              // Create a pending promise\n\twhen.resolve     = Promise.resolve;      // Create a resolved promise\n\twhen.reject      = Promise.reject;       // Create a rejected promise\n\n\twhen.lift        = lift;                 // lift a function to return promises\n\twhen['try']      = tryCall;              // call a function and return a promise\n\twhen.attempt     = tryCall;              // alias for when.try\n\n\twhen.iterate     = Promise.iterate;      // Generate a stream of promises\n\twhen.unfold      = Promise.unfold;       // Generate a stream of promises\n\n\twhen.join        = join;                 // Join 2 or more promises\n\n\twhen.all         = all;                  // Resolve a list of promises\n\twhen.settle      = settle;               // Settle a list of promises\n\n\twhen.any         = lift(Promise.any);    // One-winner race\n\twhen.some        = lift(Promise.some);   // Multi-winner race\n\n\twhen.map         = map;                  // Array.map() for promises\n\twhen.reduce      = reduce;               // Array.reduce() for promises\n\twhen.reduceRight = reduceRight;          // Array.reduceRight() for promises\n\n\twhen.isPromiseLike = isPromiseLike;      // Is something promise-like, aka thenable\n\n\twhen.Promise     = Promise;              // Promise constructor\n\twhen.defer       = defer;                // Create a {promise, resolve, reject} tuple\n\n\t/**\n\t * When x, which may be a promise, thenable, or non-promise value,\n\t *\n\t * @param {*} x\n\t * @param {function?} onFulfilled callback to be called when x is\n\t *   successfully fulfilled.  If promiseOrValue is an immediate value, callback\n\t *   will be invoked immediately.\n\t * @param {function?} onRejected callback to be called when x is\n\t *   rejected.\n\t * @param {function?} onProgress callback to be called when progress updates\n\t *   are issued for x.\n\t * @returns {Promise} a new promise that will fulfill with the return\n\t *   value of callback or errback or the completion value of promiseOrValue if\n\t *   callback and/or errback is not supplied.\n\t */\n\tfunction when(x, onFulfilled, onRejected, onProgress) {\n\t\tvar p = resolve(x);\n\t\treturn arguments.length < 2 ? p : p.then(onFulfilled, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Creates a new promise whose fate is determined by resolver.\n\t * @param {function} resolver function(resolve, reject, notify)\n\t * @returns {Promise} promise whose fate is determine by resolver\n\t */\n\tfunction promise(resolver) {\n\t\treturn new Promise(resolver);\n\t}\n\n\t/**\n\t * Lift the supplied function, creating a version of f that returns\n\t * promises, and accepts promises as arguments.\n\t * @param {function} f\n\t * @returns {Function} version of f that returns promises\n\t */\n\tfunction lift(f) {\n\t\treturn function() {\n\t\t\treturn _apply(f, this, slice.call(arguments));\n\t\t};\n\t}\n\n\t/**\n\t * Call f in a future turn, with the supplied args, and return a promise\n\t * for the result.\n\t * @param {function} f\n\t * @returns {Promise}\n\t */\n\tfunction tryCall(f /*, args... */) {\n\t\t/*jshint validthis:true */\n\t\treturn _apply(f, this, slice.call(arguments, 1));\n\t}\n\n\t/**\n\t * try/lift helper that allows specifying thisArg\n\t * @private\n\t */\n\tfunction _apply(func, thisArg, args) {\n\t\treturn Promise.all(args).then(function(args) {\n\t\t\treturn func.apply(thisArg, args);\n\t\t});\n\t}\n\n\t/**\n\t * Creates a {promise, resolver} pair, either or both of which\n\t * may be given out safely to consumers.\n\t * @return {{promise: Promise, resolve: function, reject: function, notify: function}}\n\t */\n\tfunction defer() {\n\t\treturn new Deferred();\n\t}\n\n\tfunction Deferred() {\n\t\tvar p = Promise._defer();\n\n\t\tfunction resolve(x) { p._handler.resolve(x); }\n\t\tfunction reject(x) { p._handler.reject(x); }\n\t\tfunction notify(x) { p._handler.notify(x); }\n\n\t\tthis.promise = p;\n\t\tthis.resolve = resolve;\n\t\tthis.reject = reject;\n\t\tthis.notify = notify;\n\t\tthis.resolver = { resolve: resolve, reject: reject, notify: notify };\n\t}\n\n\t/**\n\t * Determines if x is promise-like, i.e. a thenable object\n\t * NOTE: Will return true for *any thenable object*, and isn't truly\n\t * safe, since it may attempt to access the `then` property of x (i.e.\n\t *  clever/malicious getters may do weird things)\n\t * @param {*} x anything\n\t * @returns {boolean} true if x is promise-like\n\t */\n\tfunction isPromiseLike(x) {\n\t\treturn x && typeof x.then === 'function';\n\t}\n\n\t/**\n\t * Return a promise that will resolve only once all the supplied arguments\n\t * have resolved. The resolution value of the returned promise will be an array\n\t * containing the resolution values of each of the arguments.\n\t * @param {...*} arguments may be a mix of promises and values\n\t * @returns {Promise}\n\t */\n\tfunction join(/* ...promises */) {\n\t\treturn Promise.all(arguments);\n\t}\n\n\t/**\n\t * Return a promise that will fulfill once all input promises have\n\t * fulfilled, or reject when any one input promise rejects.\n\t * @param {array|Promise} promises array (or promise for an array) of promises\n\t * @returns {Promise}\n\t */\n\tfunction all(promises) {\n\t\treturn when(promises, Promise.all);\n\t}\n\n\t/**\n\t * Return a promise that will always fulfill with an array containing\n\t * the outcome states of all input promises.  The returned promise\n\t * will only reject if `promises` itself is a rejected promise.\n\t * @param {array|Promise} promises array (or promise for an array) of promises\n\t * @returns {Promise}\n\t */\n\tfunction settle(promises) {\n\t\treturn when(promises, Promise.settle);\n\t}\n\n\t/**\n\t * Promise-aware array map function, similar to `Array.prototype.map()`,\n\t * but input array may contain promises or values.\n\t * @param {Array|Promise} promises array of anything, may contain promises and values\n\t * @param {function} mapFunc map function which may return a promise or value\n\t * @returns {Promise} promise that will fulfill with an array of mapped values\n\t *  or reject if any input promise rejects.\n\t */\n\tfunction map(promises, mapFunc) {\n\t\treturn when(promises, function(promises) {\n\t\t\treturn Promise.map(promises, mapFunc);\n\t\t});\n\t}\n\n\t/**\n\t * Traditional reduce function, similar to `Array.prototype.reduce()`, but\n\t * input may contain promises and/or values, and reduceFunc\n\t * may return either a value or a promise, *and* initialValue may\n\t * be a promise for the starting value.\n\t *\n\t * @param {Array|Promise} promises array or promise for an array of anything,\n\t *      may contain a mix of promises and values.\n\t * @param {function} f reduce function reduce(currentValue, nextValue, index)\n\t * @returns {Promise} that will resolve to the final reduced value\n\t */\n\tfunction reduce(promises, f /*, initialValue */) {\n\t\t/*jshint unused:false*/\n\t\tvar args = slice.call(arguments, 1);\n\t\treturn when(promises, function(array) {\n\t\t\targs.unshift(array);\n\t\t\treturn Promise.reduce.apply(Promise, args);\n\t\t});\n\t}\n\n\t/**\n\t * Traditional reduce function, similar to `Array.prototype.reduceRight()`, but\n\t * input may contain promises and/or values, and reduceFunc\n\t * may return either a value or a promise, *and* initialValue may\n\t * be a promise for the starting value.\n\t *\n\t * @param {Array|Promise} promises array or promise for an array of anything,\n\t *      may contain a mix of promises and values.\n\t * @param {function} f reduce function reduce(currentValue, nextValue, index)\n\t * @returns {Promise} that will resolve to the final reduced value\n\t */\n\tfunction reduceRight(promises, f /*, initialValue */) {\n\t\t/*jshint unused:false*/\n\t\tvar args = slice.call(arguments, 1);\n\t\treturn when(promises, function(array) {\n\t\t\targs.unshift(array);\n\t\t\treturn Promise.reduceRight.apply(Promise, args);\n\t\t});\n\t}\n\n\treturn when;\n});\n})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}