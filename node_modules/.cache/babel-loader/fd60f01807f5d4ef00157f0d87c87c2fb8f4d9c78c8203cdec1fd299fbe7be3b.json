{"ast":null,"code":"var hasOwn = Object.prototype.hasOwnProperty;\nvar toString = Object.prototype.toString;\nfunction isPlainObject(obj) {\n  if (!obj || toString.call(obj) !== '[object Object]' || obj.nodeType || obj.setInterval) return false;\n  var has_own_constructor = hasOwn.call(obj, 'constructor');\n  var has_is_property_of_method = hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n  // Not own constructor property must be Object\n  if (obj.constructor && !has_own_constructor && !has_is_property_of_method) return false;\n\n  // Own properties are enumerated firstly, so to speed up,\n  // if last one is own, then all properties are own.\n  var key;\n  for (key in obj) {}\n  return key === undefined || hasOwn.call(obj, key);\n}\n;\nmodule.exports = function extend() {\n  var options,\n    name,\n    src,\n    copy,\n    copyIsArray,\n    clone,\n    target = arguments[0] || {},\n    i = 1,\n    length = arguments.length,\n    deep = false;\n\n  // Handle a deep copy situation\n  if (typeof target === \"boolean\") {\n    deep = target;\n    target = arguments[1] || {};\n    // skip the boolean and the target\n    i = 2;\n  }\n\n  // Handle case when target is a string or something (possible in deep copy)\n  if (typeof target !== \"object\" && typeof target !== \"function\") {\n    target = {};\n  }\n  for (; i < length; i++) {\n    // Only deal with non-null/undefined values\n    if ((options = arguments[i]) != null) {\n      // Extend the base object\n      for (name in options) {\n        src = target[name];\n        copy = options[name];\n\n        // Prevent never-ending loop\n        if (target === copy) {\n          continue;\n        }\n\n        // Recurse if we're merging plain objects or arrays\n        if (deep && copy && (isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {\n          if (copyIsArray) {\n            copyIsArray = false;\n            clone = src && Array.isArray(src) ? src : [];\n          } else {\n            clone = src && isPlainObject(src) ? src : {};\n          }\n\n          // Never move original objects, clone them\n          target[name] = extend(deep, clone, copy);\n\n          // Don't bring in undefined values\n        } else if (copy !== undefined) {\n          target[name] = copy;\n        }\n      }\n    }\n  }\n\n  // Return the modified object\n  return target;\n};","map":{"version":3,"names":["hasOwn","Object","prototype","hasOwnProperty","toString","isPlainObject","obj","call","nodeType","setInterval","has_own_constructor","has_is_property_of_method","constructor","key","undefined","module","exports","extend","options","name","src","copy","copyIsArray","clone","target","arguments","i","length","deep","Array","isArray"],"sources":["C:/Users/twotr/Desktop/College/vsCode/WorkHumanApplication/country-search/node_modules/extend/index.js"],"sourcesContent":["var hasOwn = Object.prototype.hasOwnProperty;\nvar toString = Object.prototype.toString;\n\nfunction isPlainObject(obj) {\n\tif (!obj || toString.call(obj) !== '[object Object]' || obj.nodeType || obj.setInterval)\n\t\treturn false;\n\n\tvar has_own_constructor = hasOwn.call(obj, 'constructor');\n\tvar has_is_property_of_method = hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !has_own_constructor && !has_is_property_of_method)\n\t\treturn false;\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor ( key in obj ) {}\n\n\treturn key === undefined || hasOwn.call( obj, key );\n};\n\nmodule.exports = function extend() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t    target = arguments[0] || {},\n\t    i = 1,\n\t    length = arguments.length,\n\t    deep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && typeof target !== \"function\") {\n\t\ttarget = {};\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\t\t// Only deal with non-null/undefined values\n\t\tif ( (options = arguments[ i ]) != null ) {\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( isPlainObject(copy) || (copyIsArray = Array.isArray(copy)) ) ) {\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && Array.isArray(src) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}