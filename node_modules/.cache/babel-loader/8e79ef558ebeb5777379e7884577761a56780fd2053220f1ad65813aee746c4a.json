{"ast":null,"code":"/** @license MIT License (c) copyright 2011-2013 original author or authors */\n\n/**\n * A lightweight CommonJS Promises/A and when() implementation\n * when is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n *\n * @author Brian Cavalier\n * @author John Hann\n * @version 2.8.0\n */\n(function (define) {\n  'use strict';\n\n  define(function (require) {\n    // Public API\n\n    when.promise = promise; // Create a pending promise\n    when.resolve = resolve; // Create a resolved promise\n    when.reject = reject; // Create a rejected promise\n    when.defer = defer; // Create a {promise, resolver} pair\n\n    when.join = join; // Join 2 or more promises\n\n    when.all = all; // Resolve a list of promises\n    when.map = map; // Array.map() for promises\n    when.reduce = reduce; // Array.reduce() for promises\n    when.settle = settle; // Settle a list of promises\n\n    when.any = any; // One-winner race\n    when.some = some; // Multi-winner race\n\n    when.isPromise = isPromiseLike; // DEPRECATED: use isPromiseLike\n    when.isPromiseLike = isPromiseLike; // Is something promise-like, aka thenable\n\n    /**\n     * Register an observer for a promise or immediate value.\n     *\n     * @param {*} promiseOrValue\n     * @param {function?} [onFulfilled] callback to be called when promiseOrValue is\n     *   successfully fulfilled.  If promiseOrValue is an immediate value, callback\n     *   will be invoked immediately.\n     * @param {function?} [onRejected] callback to be called when promiseOrValue is\n     *   rejected.\n     * @param {function?} [onProgress] callback to be called when progress updates\n     *   are issued for promiseOrValue.\n     * @returns {Promise} a new {@link Promise} that will complete with the return\n     *   value of callback or errback or the completion value of promiseOrValue if\n     *   callback and/or errback is not supplied.\n     */\n    function when(promiseOrValue, onFulfilled, onRejected, onProgress) {\n      // Get a trusted promise for the input promiseOrValue, and then\n      // register promise handlers\n      return cast(promiseOrValue).then(onFulfilled, onRejected, onProgress);\n    }\n\n    /**\n     * Creates a new promise whose fate is determined by resolver.\n     * @param {function} resolver function(resolve, reject, notify)\n     * @returns {Promise} promise whose fate is determine by resolver\n     */\n    function promise(resolver) {\n      return new Promise(resolver, monitorApi.PromiseStatus && monitorApi.PromiseStatus());\n    }\n\n    /**\n     * Trusted Promise constructor.  A Promise created from this constructor is\n     * a trusted when.js promise.  Any other duck-typed promise is considered\n     * untrusted.\n     * @constructor\n     * @returns {Promise} promise whose fate is determine by resolver\n     * @name Promise\n     */\n    function Promise(resolver, status) {\n      var self,\n        value,\n        consumers = [];\n      self = this;\n      this._status = status;\n      this.inspect = inspect;\n      this._when = _when;\n\n      // Call the provider resolver to seal the promise's fate\n      try {\n        resolver(promiseResolve, promiseReject, promiseNotify);\n      } catch (e) {\n        promiseReject(e);\n      }\n\n      /**\n       * Returns a snapshot of this promise's current status at the instant of call\n       * @returns {{state:String}}\n       */\n      function inspect() {\n        return value ? value.inspect() : toPendingState();\n      }\n\n      /**\n       * Private message delivery. Queues and delivers messages to\n       * the promise's ultimate fulfillment value or rejection reason.\n       * @private\n       */\n      function _when(resolve, notify, onFulfilled, onRejected, onProgress) {\n        consumers ? consumers.push(deliver) : enqueue(function () {\n          deliver(value);\n        });\n        function deliver(p) {\n          p._when(resolve, notify, onFulfilled, onRejected, onProgress);\n        }\n      }\n\n      /**\n       * Transition from pre-resolution state to post-resolution state, notifying\n       * all listeners of the ultimate fulfillment or rejection\n       * @param {*} val resolution value\n       */\n      function promiseResolve(val) {\n        if (!consumers) {\n          return;\n        }\n        var queue = consumers;\n        consumers = undef;\n        value = coerce(self, val);\n        enqueue(function () {\n          if (status) {\n            updateStatus(value, status);\n          }\n          runHandlers(queue, value);\n        });\n      }\n\n      /**\n       * Reject this promise with the supplied reason, which will be used verbatim.\n       * @param {*} reason reason for the rejection\n       */\n      function promiseReject(reason) {\n        promiseResolve(new RejectedPromise(reason));\n      }\n\n      /**\n       * Issue a progress event, notifying all progress listeners\n       * @param {*} update progress event payload to pass to all listeners\n       */\n      function promiseNotify(update) {\n        if (consumers) {\n          var queue = consumers;\n          enqueue(function () {\n            runHandlers(queue, new ProgressingPromise(update));\n          });\n        }\n      }\n    }\n    promisePrototype = Promise.prototype;\n\n    /**\n     * Register handlers for this promise.\n     * @param [onFulfilled] {Function} fulfillment handler\n     * @param [onRejected] {Function} rejection handler\n     * @param [onProgress] {Function} progress handler\n     * @return {Promise} new Promise\n     */\n    promisePrototype.then = function (onFulfilled, onRejected, onProgress) {\n      var self = this;\n      return new Promise(function (resolve, reject, notify) {\n        self._when(resolve, notify, onFulfilled, onRejected, onProgress);\n      }, this._status && this._status.observed());\n    };\n\n    /**\n     * Register a rejection handler.  Shortcut for .then(undefined, onRejected)\n     * @param {function?} onRejected\n     * @return {Promise}\n     */\n    promisePrototype['catch'] = promisePrototype.otherwise = function (onRejected) {\n      return this.then(undef, onRejected);\n    };\n\n    /**\n     * Ensures that onFulfilledOrRejected will be called regardless of whether\n     * this promise is fulfilled or rejected.  onFulfilledOrRejected WILL NOT\n     * receive the promises' value or reason.  Any returned value will be disregarded.\n     * onFulfilledOrRejected may throw or return a rejected promise to signal\n     * an additional error.\n     * @param {function} onFulfilledOrRejected handler to be called regardless of\n     *  fulfillment or rejection\n     * @returns {Promise}\n     */\n    promisePrototype['finally'] = promisePrototype.ensure = function (onFulfilledOrRejected) {\n      return typeof onFulfilledOrRejected === 'function' ? this.then(injectHandler, injectHandler)['yield'](this) : this;\n      function injectHandler() {\n        return resolve(onFulfilledOrRejected());\n      }\n    };\n\n    /**\n     * Terminate a promise chain by handling the ultimate fulfillment value or\n     * rejection reason, and assuming responsibility for all errors.  if an\n     * error propagates out of handleResult or handleFatalError, it will be\n     * rethrown to the host, resulting in a loud stack track on most platforms\n     * and a crash on some.\n     * @param {function?} handleResult\n     * @param {function?} handleError\n     * @returns {undefined}\n     */\n    promisePrototype.done = function (handleResult, handleError) {\n      this.then(handleResult, handleError)['catch'](crash);\n    };\n\n    /**\n     * Shortcut for .then(function() { return value; })\n     * @param  {*} value\n     * @return {Promise} a promise that:\n     *  - is fulfilled if value is not a promise, or\n     *  - if value is a promise, will fulfill with its value, or reject\n     *    with its reason.\n     */\n    promisePrototype['yield'] = function (value) {\n      return this.then(function () {\n        return value;\n      });\n    };\n\n    /**\n     * Runs a side effect when this promise fulfills, without changing the\n     * fulfillment value.\n     * @param {function} onFulfilledSideEffect\n     * @returns {Promise}\n     */\n    promisePrototype.tap = function (onFulfilledSideEffect) {\n      return this.then(onFulfilledSideEffect)['yield'](this);\n    };\n\n    /**\n     * Assumes that this promise will fulfill with an array, and arranges\n     * for the onFulfilled to be called with the array as its argument list\n     * i.e. onFulfilled.apply(undefined, array).\n     * @param {function} onFulfilled function to receive spread arguments\n     * @return {Promise}\n     */\n    promisePrototype.spread = function (onFulfilled) {\n      return this.then(function (array) {\n        // array may contain promises, so resolve its contents.\n        return all(array, function (array) {\n          return onFulfilled.apply(undef, array);\n        });\n      });\n    };\n\n    /**\n     * Shortcut for .then(onFulfilledOrRejected, onFulfilledOrRejected)\n     * @deprecated\n     */\n    promisePrototype.always = function (onFulfilledOrRejected, onProgress) {\n      return this.then(onFulfilledOrRejected, onFulfilledOrRejected, onProgress);\n    };\n\n    /**\n     * Casts x to a trusted promise. If x is already a trusted promise, it is\n     * returned, otherwise a new trusted Promise which follows x is returned.\n     * @param {*} x\n     * @returns {Promise}\n     */\n    function cast(x) {\n      return x instanceof Promise ? x : resolve(x);\n    }\n\n    /**\n     * Returns a resolved promise. The returned promise will be\n     *  - fulfilled with promiseOrValue if it is a value, or\n     *  - if promiseOrValue is a promise\n     *    - fulfilled with promiseOrValue's value after it is fulfilled\n     *    - rejected with promiseOrValue's reason after it is rejected\n     * In contract to cast(x), this always creates a new Promise\n     * @param  {*} x\n     * @return {Promise}\n     */\n    function resolve(x) {\n      return promise(function (resolve) {\n        resolve(x);\n      });\n    }\n\n    /**\n     * Returns a rejected promise for the supplied promiseOrValue.  The returned\n     * promise will be rejected with:\n     * - promiseOrValue, if it is a value, or\n     * - if promiseOrValue is a promise\n     *   - promiseOrValue's value after it is fulfilled\n     *   - promiseOrValue's reason after it is rejected\n     * @deprecated The behavior of when.reject in 3.0 will be to reject\n     * with x VERBATIM\n     * @param {*} x the rejected value of the returned promise\n     * @return {Promise} rejected promise\n     */\n    function reject(x) {\n      return when(x, function (e) {\n        return new RejectedPromise(e);\n      });\n    }\n\n    /**\n     * Creates a {promise, resolver} pair, either or both of which\n     * may be given out safely to consumers.\n     * The resolver has resolve, reject, and progress.  The promise\n     * has then plus extended promise API.\n     *\n     * @return {{\n     * promise: Promise,\n     * resolve: function:Promise,\n     * reject: function:Promise,\n     * notify: function:Promise\n     * resolver: {\n     *\tresolve: function:Promise,\n     *\treject: function:Promise,\n     *\tnotify: function:Promise\n     * }}}\n     */\n    function defer() {\n      var deferred, pending, resolved;\n\n      // Optimize object shape\n      deferred = {\n        promise: undef,\n        resolve: undef,\n        reject: undef,\n        notify: undef,\n        resolver: {\n          resolve: undef,\n          reject: undef,\n          notify: undef\n        }\n      };\n      deferred.promise = pending = promise(makeDeferred);\n      return deferred;\n      function makeDeferred(resolvePending, rejectPending, notifyPending) {\n        deferred.resolve = deferred.resolver.resolve = function (value) {\n          if (resolved) {\n            return resolve(value);\n          }\n          resolved = true;\n          resolvePending(value);\n          return pending;\n        };\n        deferred.reject = deferred.resolver.reject = function (reason) {\n          if (resolved) {\n            return resolve(new RejectedPromise(reason));\n          }\n          resolved = true;\n          rejectPending(reason);\n          return pending;\n        };\n        deferred.notify = deferred.resolver.notify = function (update) {\n          notifyPending(update);\n          return update;\n        };\n      }\n    }\n\n    /**\n     * Run a queue of functions as quickly as possible, passing\n     * value to each.\n     */\n    function runHandlers(queue, value) {\n      for (var i = 0; i < queue.length; i++) {\n        queue[i](value);\n      }\n    }\n\n    /**\n     * Coerces x to a trusted Promise\n     * @param {*} x thing to coerce\n     * @returns {*} Guaranteed to return a trusted Promise.  If x\n     *   is trusted, returns x, otherwise, returns a new, trusted, already-resolved\n     *   Promise whose resolution value is:\n     *   * the resolution value of x if it's a foreign promise, or\n     *   * x if it's a value\n     */\n    function coerce(self, x) {\n      if (x === self) {\n        return new RejectedPromise(new TypeError());\n      }\n      if (x instanceof Promise) {\n        return x;\n      }\n      try {\n        var untrustedThen = x === Object(x) && x.then;\n        return typeof untrustedThen === 'function' ? assimilate(untrustedThen, x) : new FulfilledPromise(x);\n      } catch (e) {\n        return new RejectedPromise(e);\n      }\n    }\n\n    /**\n     * Safely assimilates a foreign thenable by wrapping it in a trusted promise\n     * @param {function} untrustedThen x's then() method\n     * @param {object|function} x thenable\n     * @returns {Promise}\n     */\n    function assimilate(untrustedThen, x) {\n      return promise(function (resolve, reject) {\n        enqueue(function () {\n          try {\n            fcall(untrustedThen, x, resolve, reject);\n          } catch (e) {\n            reject(e);\n          }\n        });\n      });\n    }\n    makePromisePrototype = Object.create || function (o) {\n      function PromisePrototype() {}\n      PromisePrototype.prototype = o;\n      return new PromisePrototype();\n    };\n\n    /**\n     * Creates a fulfilled, local promise as a proxy for a value\n     * NOTE: must never be exposed\n     * @private\n     * @param {*} value fulfillment value\n     * @returns {Promise}\n     */\n    function FulfilledPromise(value) {\n      this.value = value;\n    }\n    FulfilledPromise.prototype = makePromisePrototype(promisePrototype);\n    FulfilledPromise.prototype.inspect = function () {\n      return toFulfilledState(this.value);\n    };\n    FulfilledPromise.prototype._when = function (resolve, _, onFulfilled) {\n      try {\n        resolve(typeof onFulfilled === 'function' ? onFulfilled(this.value) : this.value);\n      } catch (e) {\n        resolve(new RejectedPromise(e));\n      }\n    };\n\n    /**\n     * Creates a rejected, local promise as a proxy for a value\n     * NOTE: must never be exposed\n     * @private\n     * @param {*} reason rejection reason\n     * @returns {Promise}\n     */\n    function RejectedPromise(reason) {\n      this.value = reason;\n    }\n    RejectedPromise.prototype = makePromisePrototype(promisePrototype);\n    RejectedPromise.prototype.inspect = function () {\n      return toRejectedState(this.value);\n    };\n    RejectedPromise.prototype._when = function (resolve, _, __, onRejected) {\n      try {\n        resolve(typeof onRejected === 'function' ? onRejected(this.value) : this);\n      } catch (e) {\n        resolve(new RejectedPromise(e));\n      }\n    };\n\n    /**\n     * Create a progress promise with the supplied update.\n     * @private\n     * @param {*} value progress update value\n     * @return {Promise} progress promise\n     */\n    function ProgressingPromise(value) {\n      this.value = value;\n    }\n    ProgressingPromise.prototype = makePromisePrototype(promisePrototype);\n    ProgressingPromise.prototype._when = function (_, notify, f, r, u) {\n      try {\n        notify(typeof u === 'function' ? u(this.value) : this.value);\n      } catch (e) {\n        notify(e);\n      }\n    };\n\n    /**\n     * Update a PromiseStatus monitor object with the outcome\n     * of the supplied value promise.\n     * @param {Promise} value\n     * @param {PromiseStatus} status\n     */\n    function updateStatus(value, status) {\n      value.then(statusFulfilled, statusRejected);\n      function statusFulfilled() {\n        status.fulfilled();\n      }\n      function statusRejected(r) {\n        status.rejected(r);\n      }\n    }\n\n    /**\n     * Determines if x is promise-like, i.e. a thenable object\n     * NOTE: Will return true for *any thenable object*, and isn't truly\n     * safe, since it may attempt to access the `then` property of x (i.e.\n     *  clever/malicious getters may do weird things)\n     * @param {*} x anything\n     * @returns {boolean} true if x is promise-like\n     */\n    function isPromiseLike(x) {\n      return x && typeof x.then === 'function';\n    }\n\n    /**\n     * Initiates a competitive race, returning a promise that will resolve when\n     * howMany of the supplied promisesOrValues have resolved, or will reject when\n     * it becomes impossible for howMany to resolve, for example, when\n     * (promisesOrValues.length - howMany) + 1 input promises reject.\n     *\n     * @param {Array} promisesOrValues array of anything, may contain a mix\n     *      of promises and values\n     * @param howMany {number} number of promisesOrValues to resolve\n     * @param {function?} [onFulfilled] DEPRECATED, use returnedPromise.then()\n     * @param {function?} [onRejected] DEPRECATED, use returnedPromise.then()\n     * @param {function?} [onProgress] DEPRECATED, use returnedPromise.then()\n     * @returns {Promise} promise that will resolve to an array of howMany values that\n     *  resolved first, or will reject with an array of\n     *  (promisesOrValues.length - howMany) + 1 rejection reasons.\n     */\n    function some(promisesOrValues, howMany, onFulfilled, onRejected, onProgress) {\n      return when(promisesOrValues, function (promisesOrValues) {\n        return promise(resolveSome).then(onFulfilled, onRejected, onProgress);\n        function resolveSome(resolve, reject, notify) {\n          var toResolve, toReject, values, reasons, fulfillOne, rejectOne, len, i;\n          len = promisesOrValues.length >>> 0;\n          toResolve = Math.max(0, Math.min(howMany, len));\n          values = [];\n          toReject = len - toResolve + 1;\n          reasons = [];\n\n          // No items in the input, resolve immediately\n          if (!toResolve) {\n            resolve(values);\n          } else {\n            rejectOne = function (reason) {\n              reasons.push(reason);\n              if (! --toReject) {\n                fulfillOne = rejectOne = identity;\n                reject(reasons);\n              }\n            };\n            fulfillOne = function (val) {\n              // This orders the values based on promise resolution order\n              values.push(val);\n              if (! --toResolve) {\n                fulfillOne = rejectOne = identity;\n                resolve(values);\n              }\n            };\n            for (i = 0; i < len; ++i) {\n              if (i in promisesOrValues) {\n                when(promisesOrValues[i], fulfiller, rejecter, notify);\n              }\n            }\n          }\n          function rejecter(reason) {\n            rejectOne(reason);\n          }\n          function fulfiller(val) {\n            fulfillOne(val);\n          }\n        }\n      });\n    }\n\n    /**\n     * Initiates a competitive race, returning a promise that will resolve when\n     * any one of the supplied promisesOrValues has resolved or will reject when\n     * *all* promisesOrValues have rejected.\n     *\n     * @param {Array|Promise} promisesOrValues array of anything, may contain a mix\n     *      of {@link Promise}s and values\n     * @param {function?} [onFulfilled] DEPRECATED, use returnedPromise.then()\n     * @param {function?} [onRejected] DEPRECATED, use returnedPromise.then()\n     * @param {function?} [onProgress] DEPRECATED, use returnedPromise.then()\n     * @returns {Promise} promise that will resolve to the value that resolved first, or\n     * will reject with an array of all rejected inputs.\n     */\n    function any(promisesOrValues, onFulfilled, onRejected, onProgress) {\n      function unwrapSingleResult(val) {\n        return onFulfilled ? onFulfilled(val[0]) : val[0];\n      }\n      return some(promisesOrValues, 1, unwrapSingleResult, onRejected, onProgress);\n    }\n\n    /**\n     * Return a promise that will resolve only once all the supplied promisesOrValues\n     * have resolved. The resolution value of the returned promise will be an array\n     * containing the resolution values of each of the promisesOrValues.\n     * @memberOf when\n     *\n     * @param {Array|Promise} promisesOrValues array of anything, may contain a mix\n     *      of {@link Promise}s and values\n     * @param {function?} [onFulfilled] DEPRECATED, use returnedPromise.then()\n     * @param {function?} [onRejected] DEPRECATED, use returnedPromise.then()\n     * @param {function?} [onProgress] DEPRECATED, use returnedPromise.then()\n     * @returns {Promise}\n     */\n    function all(promisesOrValues, onFulfilled, onRejected, onProgress) {\n      return _map(promisesOrValues, identity).then(onFulfilled, onRejected, onProgress);\n    }\n\n    /**\n     * Joins multiple promises into a single returned promise.\n     * @return {Promise} a promise that will fulfill when *all* the input promises\n     * have fulfilled, or will reject when *any one* of the input promises rejects.\n     */\n    function join( /* ...promises */\n    ) {\n      return _map(arguments, identity);\n    }\n\n    /**\n     * Settles all input promises such that they are guaranteed not to\n     * be pending once the returned promise fulfills. The returned promise\n     * will always fulfill, except in the case where `array` is a promise\n     * that rejects.\n     * @param {Array|Promise} array or promise for array of promises to settle\n     * @returns {Promise} promise that always fulfills with an array of\n     *  outcome snapshots for each input promise.\n     */\n    function settle(array) {\n      return _map(array, toFulfilledState, toRejectedState);\n    }\n\n    /**\n     * Promise-aware array map function, similar to `Array.prototype.map()`,\n     * but input array may contain promises or values.\n     * @param {Array|Promise} array array of anything, may contain promises and values\n     * @param {function} mapFunc map function which may return a promise or value\n     * @returns {Promise} promise that will fulfill with an array of mapped values\n     *  or reject if any input promise rejects.\n     */\n    function map(array, mapFunc) {\n      return _map(array, mapFunc);\n    }\n\n    /**\n     * Internal map that allows a fallback to handle rejections\n     * @param {Array|Promise} array array of anything, may contain promises and values\n     * @param {function} mapFunc map function which may return a promise or value\n     * @param {function?} fallback function to handle rejected promises\n     * @returns {Promise} promise that will fulfill with an array of mapped values\n     *  or reject if any input promise rejects.\n     */\n    function _map(array, mapFunc, fallback) {\n      return when(array, function (array) {\n        return new Promise(resolveMap);\n        function resolveMap(resolve, reject, notify) {\n          var results, len, toResolve, i;\n\n          // Since we know the resulting length, we can preallocate the results\n          // array to avoid array expansions.\n          toResolve = len = array.length >>> 0;\n          results = [];\n          if (!toResolve) {\n            resolve(results);\n            return;\n          }\n\n          // Since mapFunc may be async, get all invocations of it into flight\n          for (i = 0; i < len; i++) {\n            if (i in array) {\n              resolveOne(array[i], i);\n            } else {\n              --toResolve;\n            }\n          }\n          function resolveOne(item, i) {\n            when(item, mapFunc, fallback).then(function (mapped) {\n              results[i] = mapped;\n              if (! --toResolve) {\n                resolve(results);\n              }\n            }, reject, notify);\n          }\n        }\n      });\n    }\n\n    /**\n     * Traditional reduce function, similar to `Array.prototype.reduce()`, but\n     * input may contain promises and/or values, and reduceFunc\n     * may return either a value or a promise, *and* initialValue may\n     * be a promise for the starting value.\n     *\n     * @param {Array|Promise} promise array or promise for an array of anything,\n     *      may contain a mix of promises and values.\n     * @param {function} reduceFunc reduce function reduce(currentValue, nextValue, index, total),\n     *      where total is the total number of items being reduced, and will be the same\n     *      in each call to reduceFunc.\n     * @returns {Promise} that will resolve to the final reduced value\n     */\n    function reduce(promise, reduceFunc /*, initialValue */) {\n      var args = fcall(slice, arguments, 1);\n      return when(promise, function (array) {\n        var total;\n        total = array.length;\n\n        // Wrap the supplied reduceFunc with one that handles promises and then\n        // delegates to the supplied.\n        args[0] = function (current, val, i) {\n          return when(current, function (c) {\n            return when(val, function (value) {\n              return reduceFunc(c, value, i, total);\n            });\n          });\n        };\n        return reduceArray.apply(array, args);\n      });\n    }\n\n    // Snapshot states\n\n    /**\n     * Creates a fulfilled state snapshot\n     * @private\n     * @param {*} x any value\n     * @returns {{state:'fulfilled',value:*}}\n     */\n    function toFulfilledState(x) {\n      return {\n        state: 'fulfilled',\n        value: x\n      };\n    }\n\n    /**\n     * Creates a rejected state snapshot\n     * @private\n     * @param {*} x any reason\n     * @returns {{state:'rejected',reason:*}}\n     */\n    function toRejectedState(x) {\n      return {\n        state: 'rejected',\n        reason: x\n      };\n    }\n\n    /**\n     * Creates a pending state snapshot\n     * @private\n     * @returns {{state:'pending'}}\n     */\n    function toPendingState() {\n      return {\n        state: 'pending'\n      };\n    }\n\n    //\n    // Internals, utilities, etc.\n    //\n\n    var promisePrototype, makePromisePrototype, reduceArray, slice, fcall, nextTick, handlerQueue, funcProto, call, arrayProto, monitorApi, capturedSetTimeout, cjsRequire, MutationObs, undef;\n    cjsRequire = require;\n\n    //\n    // Shared handler queue processing\n    //\n    // Credit to Twisol (https://github.com/Twisol) for suggesting\n    // this type of extensible queue + trampoline approach for\n    // next-tick conflation.\n\n    handlerQueue = [];\n\n    /**\n     * Enqueue a task. If the queue is not currently scheduled to be\n     * drained, schedule it.\n     * @param {function} task\n     */\n    function enqueue(task) {\n      if (handlerQueue.push(task) === 1) {\n        nextTick(drainQueue);\n      }\n    }\n\n    /**\n     * Drain the handler queue entirely, being careful to allow the\n     * queue to be extended while it is being processed, and to continue\n     * processing until it is truly empty.\n     */\n    function drainQueue() {\n      runHandlers(handlerQueue);\n      handlerQueue = [];\n    }\n\n    // Allow attaching the monitor to when() if env has no console\n    monitorApi = typeof console !== 'undefined' ? console : when;\n\n    // Sniff \"best\" async scheduling option\n    // Prefer process.nextTick or MutationObserver, then check for\n    // vertx and finally fall back to setTimeout\n    /*global process,document,setTimeout,MutationObserver,WebKitMutationObserver*/\n    if (typeof process === 'object' && process.nextTick) {\n      nextTick = process.nextTick;\n    } else if (MutationObs = typeof MutationObserver === 'function' && MutationObserver || typeof WebKitMutationObserver === 'function' && WebKitMutationObserver) {\n      nextTick = function (document, MutationObserver, drainQueue) {\n        var el = document.createElement('div');\n        new MutationObserver(drainQueue).observe(el, {\n          attributes: true\n        });\n        return function () {\n          el.setAttribute('x', 'x');\n        };\n      }(document, MutationObs, drainQueue);\n    } else {\n      try {\n        // vert.x 1.x || 2.x\n        nextTick = cjsRequire('vertx').runOnLoop || cjsRequire('vertx').runOnContext;\n      } catch (ignore) {\n        // capture setTimeout to avoid being caught by fake timers\n        // used in time based tests\n        capturedSetTimeout = setTimeout;\n        nextTick = function (t) {\n          capturedSetTimeout(t, 0);\n        };\n      }\n    }\n\n    //\n    // Capture/polyfill function and array utils\n    //\n\n    // Safe function calls\n    funcProto = Function.prototype;\n    call = funcProto.call;\n    fcall = funcProto.bind ? call.bind(call) : function (f, context) {\n      return f.apply(context, slice.call(arguments, 2));\n    };\n\n    // Safe array ops\n    arrayProto = [];\n    slice = arrayProto.slice;\n\n    // ES5 reduce implementation if native not available\n    // See: http://es5.github.com/#x15.4.4.21 as there are many\n    // specifics and edge cases.  ES5 dictates that reduce.length === 1\n    // This implementation deviates from ES5 spec in the following ways:\n    // 1. It does not check if reduceFunc is a Callable\n    reduceArray = arrayProto.reduce || function (reduceFunc /*, initialValue */) {\n      /*jshint maxcomplexity: 7*/\n      var arr, args, reduced, len, i;\n      i = 0;\n      arr = Object(this);\n      len = arr.length >>> 0;\n      args = arguments;\n\n      // If no initialValue, use first item of array (we know length !== 0 here)\n      // and adjust i to start at second item\n      if (args.length <= 1) {\n        // Skip to the first real element in the array\n        for (;;) {\n          if (i in arr) {\n            reduced = arr[i++];\n            break;\n          }\n\n          // If we reached the end of the array without finding any real\n          // elements, it's a TypeError\n          if (++i >= len) {\n            throw new TypeError();\n          }\n        }\n      } else {\n        // If initialValue provided, use it\n        reduced = args[1];\n      }\n\n      // Do the actual reduce\n      for (; i < len; ++i) {\n        if (i in arr) {\n          reduced = reduceFunc(reduced, arr[i], i, arr);\n        }\n      }\n      return reduced;\n    };\n    function identity(x) {\n      return x;\n    }\n    function crash(fatalError) {\n      if (typeof monitorApi.reportUnhandled === 'function') {\n        monitorApi.reportUnhandled();\n      } else {\n        enqueue(function () {\n          throw fatalError;\n        });\n      }\n      throw fatalError;\n    }\n    return when;\n  });\n})(typeof define === 'function' && define.amd ? define : function (factory) {\n  module.exports = factory(require);\n});","map":{"version":3,"names":["define","require","when","promise","resolve","reject","defer","join","all","map","reduce","settle","any","some","isPromise","isPromiseLike","promiseOrValue","onFulfilled","onRejected","onProgress","cast","then","resolver","Promise","monitorApi","PromiseStatus","status","self","value","consumers","_status","inspect","_when","promiseResolve","promiseReject","promiseNotify","e","toPendingState","notify","push","deliver","enqueue","p","val","queue","undef","coerce","updateStatus","runHandlers","reason","RejectedPromise","update","ProgressingPromise","promisePrototype","prototype","observed","otherwise","ensure","onFulfilledOrRejected","injectHandler","done","handleResult","handleError","crash","tap","onFulfilledSideEffect","spread","array","apply","always","x","deferred","pending","resolved","makeDeferred","resolvePending","rejectPending","notifyPending","i","length","TypeError","untrustedThen","Object","assimilate","FulfilledPromise","fcall","makePromisePrototype","create","o","PromisePrototype","toFulfilledState","_","toRejectedState","__","f","r","u","statusFulfilled","statusRejected","fulfilled","rejected","promisesOrValues","howMany","resolveSome","toResolve","toReject","values","reasons","fulfillOne","rejectOne","len","Math","max","min","identity","fulfiller","rejecter","unwrapSingleResult","_map","arguments","mapFunc","fallback","resolveMap","results","resolveOne","item","mapped","reduceFunc","args","slice","total","current","c","reduceArray","state","nextTick","handlerQueue","funcProto","call","arrayProto","capturedSetTimeout","cjsRequire","MutationObs","task","drainQueue","console","process","MutationObserver","WebKitMutationObserver","document","el","createElement","observe","attributes","setAttribute","runOnLoop","runOnContext","ignore","setTimeout","t","Function","bind","context","arr","reduced","fatalError","reportUnhandled","amd","factory","module","exports"],"sources":["C:/Users/twotr/Desktop/College/vsCode/WorkHumanApplication/country-search/node_modules/when/when.js"],"sourcesContent":["/** @license MIT License (c) copyright 2011-2013 original author or authors */\n\n/**\n * A lightweight CommonJS Promises/A and when() implementation\n * when is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n *\n * @author Brian Cavalier\n * @author John Hann\n * @version 2.8.0\n */\n(function(define) { 'use strict';\ndefine(function (require) {\n\n\t// Public API\n\n\twhen.promise   = promise;    // Create a pending promise\n\twhen.resolve   = resolve;    // Create a resolved promise\n\twhen.reject    = reject;     // Create a rejected promise\n\twhen.defer     = defer;      // Create a {promise, resolver} pair\n\n\twhen.join      = join;       // Join 2 or more promises\n\n\twhen.all       = all;        // Resolve a list of promises\n\twhen.map       = map;        // Array.map() for promises\n\twhen.reduce    = reduce;     // Array.reduce() for promises\n\twhen.settle    = settle;     // Settle a list of promises\n\n\twhen.any       = any;        // One-winner race\n\twhen.some      = some;       // Multi-winner race\n\n\twhen.isPromise = isPromiseLike;  // DEPRECATED: use isPromiseLike\n\twhen.isPromiseLike = isPromiseLike; // Is something promise-like, aka thenable\n\n\t/**\n\t * Register an observer for a promise or immediate value.\n\t *\n\t * @param {*} promiseOrValue\n\t * @param {function?} [onFulfilled] callback to be called when promiseOrValue is\n\t *   successfully fulfilled.  If promiseOrValue is an immediate value, callback\n\t *   will be invoked immediately.\n\t * @param {function?} [onRejected] callback to be called when promiseOrValue is\n\t *   rejected.\n\t * @param {function?} [onProgress] callback to be called when progress updates\n\t *   are issued for promiseOrValue.\n\t * @returns {Promise} a new {@link Promise} that will complete with the return\n\t *   value of callback or errback or the completion value of promiseOrValue if\n\t *   callback and/or errback is not supplied.\n\t */\n\tfunction when(promiseOrValue, onFulfilled, onRejected, onProgress) {\n\t\t// Get a trusted promise for the input promiseOrValue, and then\n\t\t// register promise handlers\n\t\treturn cast(promiseOrValue).then(onFulfilled, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Creates a new promise whose fate is determined by resolver.\n\t * @param {function} resolver function(resolve, reject, notify)\n\t * @returns {Promise} promise whose fate is determine by resolver\n\t */\n\tfunction promise(resolver) {\n\t\treturn new Promise(resolver,\n\t\t\tmonitorApi.PromiseStatus && monitorApi.PromiseStatus());\n\t}\n\n\t/**\n\t * Trusted Promise constructor.  A Promise created from this constructor is\n\t * a trusted when.js promise.  Any other duck-typed promise is considered\n\t * untrusted.\n\t * @constructor\n\t * @returns {Promise} promise whose fate is determine by resolver\n\t * @name Promise\n\t */\n\tfunction Promise(resolver, status) {\n\t\tvar self, value, consumers = [];\n\n\t\tself = this;\n\t\tthis._status = status;\n\t\tthis.inspect = inspect;\n\t\tthis._when = _when;\n\n\t\t// Call the provider resolver to seal the promise's fate\n\t\ttry {\n\t\t\tresolver(promiseResolve, promiseReject, promiseNotify);\n\t\t} catch(e) {\n\t\t\tpromiseReject(e);\n\t\t}\n\n\t\t/**\n\t\t * Returns a snapshot of this promise's current status at the instant of call\n\t\t * @returns {{state:String}}\n\t\t */\n\t\tfunction inspect() {\n\t\t\treturn value ? value.inspect() : toPendingState();\n\t\t}\n\n\t\t/**\n\t\t * Private message delivery. Queues and delivers messages to\n\t\t * the promise's ultimate fulfillment value or rejection reason.\n\t\t * @private\n\t\t */\n\t\tfunction _when(resolve, notify, onFulfilled, onRejected, onProgress) {\n\t\t\tconsumers ? consumers.push(deliver) : enqueue(function() { deliver(value); });\n\n\t\t\tfunction deliver(p) {\n\t\t\t\tp._when(resolve, notify, onFulfilled, onRejected, onProgress);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Transition from pre-resolution state to post-resolution state, notifying\n\t\t * all listeners of the ultimate fulfillment or rejection\n\t\t * @param {*} val resolution value\n\t\t */\n\t\tfunction promiseResolve(val) {\n\t\t\tif(!consumers) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar queue = consumers;\n\t\t\tconsumers = undef;\n\n\t\t\tvalue = coerce(self, val);\n\t\t\tenqueue(function () {\n\t\t\t\tif(status) {\n\t\t\t\t\tupdateStatus(value, status);\n\t\t\t\t}\n\t\t\t\trunHandlers(queue, value);\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Reject this promise with the supplied reason, which will be used verbatim.\n\t\t * @param {*} reason reason for the rejection\n\t\t */\n\t\tfunction promiseReject(reason) {\n\t\t\tpromiseResolve(new RejectedPromise(reason));\n\t\t}\n\n\t\t/**\n\t\t * Issue a progress event, notifying all progress listeners\n\t\t * @param {*} update progress event payload to pass to all listeners\n\t\t */\n\t\tfunction promiseNotify(update) {\n\t\t\tif(consumers) {\n\t\t\t\tvar queue = consumers;\n\t\t\t\tenqueue(function () {\n\t\t\t\t\trunHandlers(queue, new ProgressingPromise(update));\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\tpromisePrototype = Promise.prototype;\n\n\t/**\n\t * Register handlers for this promise.\n\t * @param [onFulfilled] {Function} fulfillment handler\n\t * @param [onRejected] {Function} rejection handler\n\t * @param [onProgress] {Function} progress handler\n\t * @return {Promise} new Promise\n\t */\n\tpromisePrototype.then = function(onFulfilled, onRejected, onProgress) {\n\t\tvar self = this;\n\n\t\treturn new Promise(function(resolve, reject, notify) {\n\t\t\tself._when(resolve, notify, onFulfilled, onRejected, onProgress);\n\t\t}, this._status && this._status.observed());\n\t};\n\n\t/**\n\t * Register a rejection handler.  Shortcut for .then(undefined, onRejected)\n\t * @param {function?} onRejected\n\t * @return {Promise}\n\t */\n\tpromisePrototype['catch'] = promisePrototype.otherwise = function(onRejected) {\n\t\treturn this.then(undef, onRejected);\n\t};\n\n\t/**\n\t * Ensures that onFulfilledOrRejected will be called regardless of whether\n\t * this promise is fulfilled or rejected.  onFulfilledOrRejected WILL NOT\n\t * receive the promises' value or reason.  Any returned value will be disregarded.\n\t * onFulfilledOrRejected may throw or return a rejected promise to signal\n\t * an additional error.\n\t * @param {function} onFulfilledOrRejected handler to be called regardless of\n\t *  fulfillment or rejection\n\t * @returns {Promise}\n\t */\n\tpromisePrototype['finally'] = promisePrototype.ensure = function(onFulfilledOrRejected) {\n\t\treturn typeof onFulfilledOrRejected === 'function'\n\t\t\t? this.then(injectHandler, injectHandler)['yield'](this)\n\t\t\t: this;\n\n\t\tfunction injectHandler() {\n\t\t\treturn resolve(onFulfilledOrRejected());\n\t\t}\n\t};\n\n\t/**\n\t * Terminate a promise chain by handling the ultimate fulfillment value or\n\t * rejection reason, and assuming responsibility for all errors.  if an\n\t * error propagates out of handleResult or handleFatalError, it will be\n\t * rethrown to the host, resulting in a loud stack track on most platforms\n\t * and a crash on some.\n\t * @param {function?} handleResult\n\t * @param {function?} handleError\n\t * @returns {undefined}\n\t */\n\tpromisePrototype.done = function(handleResult, handleError) {\n\t\tthis.then(handleResult, handleError)['catch'](crash);\n\t};\n\n\t/**\n\t * Shortcut for .then(function() { return value; })\n\t * @param  {*} value\n\t * @return {Promise} a promise that:\n\t *  - is fulfilled if value is not a promise, or\n\t *  - if value is a promise, will fulfill with its value, or reject\n\t *    with its reason.\n\t */\n\tpromisePrototype['yield'] = function(value) {\n\t\treturn this.then(function() {\n\t\t\treturn value;\n\t\t});\n\t};\n\n\t/**\n\t * Runs a side effect when this promise fulfills, without changing the\n\t * fulfillment value.\n\t * @param {function} onFulfilledSideEffect\n\t * @returns {Promise}\n\t */\n\tpromisePrototype.tap = function(onFulfilledSideEffect) {\n\t\treturn this.then(onFulfilledSideEffect)['yield'](this);\n\t};\n\n\t/**\n\t * Assumes that this promise will fulfill with an array, and arranges\n\t * for the onFulfilled to be called with the array as its argument list\n\t * i.e. onFulfilled.apply(undefined, array).\n\t * @param {function} onFulfilled function to receive spread arguments\n\t * @return {Promise}\n\t */\n\tpromisePrototype.spread = function(onFulfilled) {\n\t\treturn this.then(function(array) {\n\t\t\t// array may contain promises, so resolve its contents.\n\t\t\treturn all(array, function(array) {\n\t\t\t\treturn onFulfilled.apply(undef, array);\n\t\t\t});\n\t\t});\n\t};\n\n\t/**\n\t * Shortcut for .then(onFulfilledOrRejected, onFulfilledOrRejected)\n\t * @deprecated\n\t */\n\tpromisePrototype.always = function(onFulfilledOrRejected, onProgress) {\n\t\treturn this.then(onFulfilledOrRejected, onFulfilledOrRejected, onProgress);\n\t};\n\n\t/**\n\t * Casts x to a trusted promise. If x is already a trusted promise, it is\n\t * returned, otherwise a new trusted Promise which follows x is returned.\n\t * @param {*} x\n\t * @returns {Promise}\n\t */\n\tfunction cast(x) {\n\t\treturn x instanceof Promise ? x : resolve(x);\n\t}\n\n\t/**\n\t * Returns a resolved promise. The returned promise will be\n\t *  - fulfilled with promiseOrValue if it is a value, or\n\t *  - if promiseOrValue is a promise\n\t *    - fulfilled with promiseOrValue's value after it is fulfilled\n\t *    - rejected with promiseOrValue's reason after it is rejected\n\t * In contract to cast(x), this always creates a new Promise\n\t * @param  {*} x\n\t * @return {Promise}\n\t */\n\tfunction resolve(x) {\n\t\treturn promise(function(resolve) {\n\t\t\tresolve(x);\n\t\t});\n\t}\n\n\t/**\n\t * Returns a rejected promise for the supplied promiseOrValue.  The returned\n\t * promise will be rejected with:\n\t * - promiseOrValue, if it is a value, or\n\t * - if promiseOrValue is a promise\n\t *   - promiseOrValue's value after it is fulfilled\n\t *   - promiseOrValue's reason after it is rejected\n\t * @deprecated The behavior of when.reject in 3.0 will be to reject\n\t * with x VERBATIM\n\t * @param {*} x the rejected value of the returned promise\n\t * @return {Promise} rejected promise\n\t */\n\tfunction reject(x) {\n\t\treturn when(x, function(e) {\n\t\t\treturn new RejectedPromise(e);\n\t\t});\n\t}\n\n\t/**\n\t * Creates a {promise, resolver} pair, either or both of which\n\t * may be given out safely to consumers.\n\t * The resolver has resolve, reject, and progress.  The promise\n\t * has then plus extended promise API.\n\t *\n\t * @return {{\n\t * promise: Promise,\n\t * resolve: function:Promise,\n\t * reject: function:Promise,\n\t * notify: function:Promise\n\t * resolver: {\n\t *\tresolve: function:Promise,\n\t *\treject: function:Promise,\n\t *\tnotify: function:Promise\n\t * }}}\n\t */\n\tfunction defer() {\n\t\tvar deferred, pending, resolved;\n\n\t\t// Optimize object shape\n\t\tdeferred = {\n\t\t\tpromise: undef, resolve: undef, reject: undef, notify: undef,\n\t\t\tresolver: { resolve: undef, reject: undef, notify: undef }\n\t\t};\n\n\t\tdeferred.promise = pending = promise(makeDeferred);\n\n\t\treturn deferred;\n\n\t\tfunction makeDeferred(resolvePending, rejectPending, notifyPending) {\n\t\t\tdeferred.resolve = deferred.resolver.resolve = function(value) {\n\t\t\t\tif(resolved) {\n\t\t\t\t\treturn resolve(value);\n\t\t\t\t}\n\t\t\t\tresolved = true;\n\t\t\t\tresolvePending(value);\n\t\t\t\treturn pending;\n\t\t\t};\n\n\t\t\tdeferred.reject  = deferred.resolver.reject  = function(reason) {\n\t\t\t\tif(resolved) {\n\t\t\t\t\treturn resolve(new RejectedPromise(reason));\n\t\t\t\t}\n\t\t\t\tresolved = true;\n\t\t\t\trejectPending(reason);\n\t\t\t\treturn pending;\n\t\t\t};\n\n\t\t\tdeferred.notify  = deferred.resolver.notify  = function(update) {\n\t\t\t\tnotifyPending(update);\n\t\t\t\treturn update;\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Run a queue of functions as quickly as possible, passing\n\t * value to each.\n\t */\n\tfunction runHandlers(queue, value) {\n\t\tfor (var i = 0; i < queue.length; i++) {\n\t\t\tqueue[i](value);\n\t\t}\n\t}\n\n\t/**\n\t * Coerces x to a trusted Promise\n\t * @param {*} x thing to coerce\n\t * @returns {*} Guaranteed to return a trusted Promise.  If x\n\t *   is trusted, returns x, otherwise, returns a new, trusted, already-resolved\n\t *   Promise whose resolution value is:\n\t *   * the resolution value of x if it's a foreign promise, or\n\t *   * x if it's a value\n\t */\n\tfunction coerce(self, x) {\n\t\tif (x === self) {\n\t\t\treturn new RejectedPromise(new TypeError());\n\t\t}\n\n\t\tif (x instanceof Promise) {\n\t\t\treturn x;\n\t\t}\n\n\t\ttry {\n\t\t\tvar untrustedThen = x === Object(x) && x.then;\n\n\t\t\treturn typeof untrustedThen === 'function'\n\t\t\t\t? assimilate(untrustedThen, x)\n\t\t\t\t: new FulfilledPromise(x);\n\t\t} catch(e) {\n\t\t\treturn new RejectedPromise(e);\n\t\t}\n\t}\n\n\t/**\n\t * Safely assimilates a foreign thenable by wrapping it in a trusted promise\n\t * @param {function} untrustedThen x's then() method\n\t * @param {object|function} x thenable\n\t * @returns {Promise}\n\t */\n\tfunction assimilate(untrustedThen, x) {\n\t\treturn promise(function (resolve, reject) {\n\t\t\tenqueue(function() {\n\t\t\t\ttry {\n\t\t\t\t\tfcall(untrustedThen, x, resolve, reject);\n\t\t\t\t} catch(e) {\n\t\t\t\t\treject(e);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tmakePromisePrototype = Object.create ||\n\t\tfunction(o) {\n\t\t\tfunction PromisePrototype() {}\n\t\t\tPromisePrototype.prototype = o;\n\t\t\treturn new PromisePrototype();\n\t\t};\n\n\t/**\n\t * Creates a fulfilled, local promise as a proxy for a value\n\t * NOTE: must never be exposed\n\t * @private\n\t * @param {*} value fulfillment value\n\t * @returns {Promise}\n\t */\n\tfunction FulfilledPromise(value) {\n\t\tthis.value = value;\n\t}\n\n\tFulfilledPromise.prototype = makePromisePrototype(promisePrototype);\n\n\tFulfilledPromise.prototype.inspect = function() {\n\t\treturn toFulfilledState(this.value);\n\t};\n\n\tFulfilledPromise.prototype._when = function(resolve, _, onFulfilled) {\n\t\ttry {\n\t\t\tresolve(typeof onFulfilled === 'function' ? onFulfilled(this.value) : this.value);\n\t\t} catch(e) {\n\t\t\tresolve(new RejectedPromise(e));\n\t\t}\n\t};\n\n\t/**\n\t * Creates a rejected, local promise as a proxy for a value\n\t * NOTE: must never be exposed\n\t * @private\n\t * @param {*} reason rejection reason\n\t * @returns {Promise}\n\t */\n\tfunction RejectedPromise(reason) {\n\t\tthis.value = reason;\n\t}\n\n\tRejectedPromise.prototype = makePromisePrototype(promisePrototype);\n\n\tRejectedPromise.prototype.inspect = function() {\n\t\treturn toRejectedState(this.value);\n\t};\n\n\tRejectedPromise.prototype._when = function(resolve, _, __, onRejected) {\n\t\ttry {\n\t\t\tresolve(typeof onRejected === 'function' ? onRejected(this.value) : this);\n\t\t} catch(e) {\n\t\t\tresolve(new RejectedPromise(e));\n\t\t}\n\t};\n\n\t/**\n\t * Create a progress promise with the supplied update.\n\t * @private\n\t * @param {*} value progress update value\n\t * @return {Promise} progress promise\n\t */\n\tfunction ProgressingPromise(value) {\n\t\tthis.value = value;\n\t}\n\n\tProgressingPromise.prototype = makePromisePrototype(promisePrototype);\n\n\tProgressingPromise.prototype._when = function(_, notify, f, r, u) {\n\t\ttry {\n\t\t\tnotify(typeof u === 'function' ? u(this.value) : this.value);\n\t\t} catch(e) {\n\t\t\tnotify(e);\n\t\t}\n\t};\n\n\t/**\n\t * Update a PromiseStatus monitor object with the outcome\n\t * of the supplied value promise.\n\t * @param {Promise} value\n\t * @param {PromiseStatus} status\n\t */\n\tfunction updateStatus(value, status) {\n\t\tvalue.then(statusFulfilled, statusRejected);\n\n\t\tfunction statusFulfilled() { status.fulfilled(); }\n\t\tfunction statusRejected(r) { status.rejected(r); }\n\t}\n\n\t/**\n\t * Determines if x is promise-like, i.e. a thenable object\n\t * NOTE: Will return true for *any thenable object*, and isn't truly\n\t * safe, since it may attempt to access the `then` property of x (i.e.\n\t *  clever/malicious getters may do weird things)\n\t * @param {*} x anything\n\t * @returns {boolean} true if x is promise-like\n\t */\n\tfunction isPromiseLike(x) {\n\t\treturn x && typeof x.then === 'function';\n\t}\n\n\t/**\n\t * Initiates a competitive race, returning a promise that will resolve when\n\t * howMany of the supplied promisesOrValues have resolved, or will reject when\n\t * it becomes impossible for howMany to resolve, for example, when\n\t * (promisesOrValues.length - howMany) + 1 input promises reject.\n\t *\n\t * @param {Array} promisesOrValues array of anything, may contain a mix\n\t *      of promises and values\n\t * @param howMany {number} number of promisesOrValues to resolve\n\t * @param {function?} [onFulfilled] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onRejected] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onProgress] DEPRECATED, use returnedPromise.then()\n\t * @returns {Promise} promise that will resolve to an array of howMany values that\n\t *  resolved first, or will reject with an array of\n\t *  (promisesOrValues.length - howMany) + 1 rejection reasons.\n\t */\n\tfunction some(promisesOrValues, howMany, onFulfilled, onRejected, onProgress) {\n\n\t\treturn when(promisesOrValues, function(promisesOrValues) {\n\n\t\t\treturn promise(resolveSome).then(onFulfilled, onRejected, onProgress);\n\n\t\t\tfunction resolveSome(resolve, reject, notify) {\n\t\t\t\tvar toResolve, toReject, values, reasons, fulfillOne, rejectOne, len, i;\n\n\t\t\t\tlen = promisesOrValues.length >>> 0;\n\n\t\t\t\ttoResolve = Math.max(0, Math.min(howMany, len));\n\t\t\t\tvalues = [];\n\n\t\t\t\ttoReject = (len - toResolve) + 1;\n\t\t\t\treasons = [];\n\n\t\t\t\t// No items in the input, resolve immediately\n\t\t\t\tif (!toResolve) {\n\t\t\t\t\tresolve(values);\n\n\t\t\t\t} else {\n\t\t\t\t\trejectOne = function(reason) {\n\t\t\t\t\t\treasons.push(reason);\n\t\t\t\t\t\tif(!--toReject) {\n\t\t\t\t\t\t\tfulfillOne = rejectOne = identity;\n\t\t\t\t\t\t\treject(reasons);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tfulfillOne = function(val) {\n\t\t\t\t\t\t// This orders the values based on promise resolution order\n\t\t\t\t\t\tvalues.push(val);\n\t\t\t\t\t\tif (!--toResolve) {\n\t\t\t\t\t\t\tfulfillOne = rejectOne = identity;\n\t\t\t\t\t\t\tresolve(values);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tfor(i = 0; i < len; ++i) {\n\t\t\t\t\t\tif(i in promisesOrValues) {\n\t\t\t\t\t\t\twhen(promisesOrValues[i], fulfiller, rejecter, notify);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction rejecter(reason) {\n\t\t\t\t\trejectOne(reason);\n\t\t\t\t}\n\n\t\t\t\tfunction fulfiller(val) {\n\t\t\t\t\tfulfillOne(val);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Initiates a competitive race, returning a promise that will resolve when\n\t * any one of the supplied promisesOrValues has resolved or will reject when\n\t * *all* promisesOrValues have rejected.\n\t *\n\t * @param {Array|Promise} promisesOrValues array of anything, may contain a mix\n\t *      of {@link Promise}s and values\n\t * @param {function?} [onFulfilled] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onRejected] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onProgress] DEPRECATED, use returnedPromise.then()\n\t * @returns {Promise} promise that will resolve to the value that resolved first, or\n\t * will reject with an array of all rejected inputs.\n\t */\n\tfunction any(promisesOrValues, onFulfilled, onRejected, onProgress) {\n\n\t\tfunction unwrapSingleResult(val) {\n\t\t\treturn onFulfilled ? onFulfilled(val[0]) : val[0];\n\t\t}\n\n\t\treturn some(promisesOrValues, 1, unwrapSingleResult, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Return a promise that will resolve only once all the supplied promisesOrValues\n\t * have resolved. The resolution value of the returned promise will be an array\n\t * containing the resolution values of each of the promisesOrValues.\n\t * @memberOf when\n\t *\n\t * @param {Array|Promise} promisesOrValues array of anything, may contain a mix\n\t *      of {@link Promise}s and values\n\t * @param {function?} [onFulfilled] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onRejected] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onProgress] DEPRECATED, use returnedPromise.then()\n\t * @returns {Promise}\n\t */\n\tfunction all(promisesOrValues, onFulfilled, onRejected, onProgress) {\n\t\treturn _map(promisesOrValues, identity).then(onFulfilled, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Joins multiple promises into a single returned promise.\n\t * @return {Promise} a promise that will fulfill when *all* the input promises\n\t * have fulfilled, or will reject when *any one* of the input promises rejects.\n\t */\n\tfunction join(/* ...promises */) {\n\t\treturn _map(arguments, identity);\n\t}\n\n\t/**\n\t * Settles all input promises such that they are guaranteed not to\n\t * be pending once the returned promise fulfills. The returned promise\n\t * will always fulfill, except in the case where `array` is a promise\n\t * that rejects.\n\t * @param {Array|Promise} array or promise for array of promises to settle\n\t * @returns {Promise} promise that always fulfills with an array of\n\t *  outcome snapshots for each input promise.\n\t */\n\tfunction settle(array) {\n\t\treturn _map(array, toFulfilledState, toRejectedState);\n\t}\n\n\t/**\n\t * Promise-aware array map function, similar to `Array.prototype.map()`,\n\t * but input array may contain promises or values.\n\t * @param {Array|Promise} array array of anything, may contain promises and values\n\t * @param {function} mapFunc map function which may return a promise or value\n\t * @returns {Promise} promise that will fulfill with an array of mapped values\n\t *  or reject if any input promise rejects.\n\t */\n\tfunction map(array, mapFunc) {\n\t\treturn _map(array, mapFunc);\n\t}\n\n\t/**\n\t * Internal map that allows a fallback to handle rejections\n\t * @param {Array|Promise} array array of anything, may contain promises and values\n\t * @param {function} mapFunc map function which may return a promise or value\n\t * @param {function?} fallback function to handle rejected promises\n\t * @returns {Promise} promise that will fulfill with an array of mapped values\n\t *  or reject if any input promise rejects.\n\t */\n\tfunction _map(array, mapFunc, fallback) {\n\t\treturn when(array, function(array) {\n\n\t\t\treturn new Promise(resolveMap);\n\n\t\t\tfunction resolveMap(resolve, reject, notify) {\n\t\t\t\tvar results, len, toResolve, i;\n\n\t\t\t\t// Since we know the resulting length, we can preallocate the results\n\t\t\t\t// array to avoid array expansions.\n\t\t\t\ttoResolve = len = array.length >>> 0;\n\t\t\t\tresults = [];\n\n\t\t\t\tif(!toResolve) {\n\t\t\t\t\tresolve(results);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Since mapFunc may be async, get all invocations of it into flight\n\t\t\t\tfor(i = 0; i < len; i++) {\n\t\t\t\t\tif(i in array) {\n\t\t\t\t\t\tresolveOne(array[i], i);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t--toResolve;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction resolveOne(item, i) {\n\t\t\t\t\twhen(item, mapFunc, fallback).then(function(mapped) {\n\t\t\t\t\t\tresults[i] = mapped;\n\n\t\t\t\t\t\tif(!--toResolve) {\n\t\t\t\t\t\t\tresolve(results);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, reject, notify);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Traditional reduce function, similar to `Array.prototype.reduce()`, but\n\t * input may contain promises and/or values, and reduceFunc\n\t * may return either a value or a promise, *and* initialValue may\n\t * be a promise for the starting value.\n\t *\n\t * @param {Array|Promise} promise array or promise for an array of anything,\n\t *      may contain a mix of promises and values.\n\t * @param {function} reduceFunc reduce function reduce(currentValue, nextValue, index, total),\n\t *      where total is the total number of items being reduced, and will be the same\n\t *      in each call to reduceFunc.\n\t * @returns {Promise} that will resolve to the final reduced value\n\t */\n\tfunction reduce(promise, reduceFunc /*, initialValue */) {\n\t\tvar args = fcall(slice, arguments, 1);\n\n\t\treturn when(promise, function(array) {\n\t\t\tvar total;\n\n\t\t\ttotal = array.length;\n\n\t\t\t// Wrap the supplied reduceFunc with one that handles promises and then\n\t\t\t// delegates to the supplied.\n\t\t\targs[0] = function (current, val, i) {\n\t\t\t\treturn when(current, function (c) {\n\t\t\t\t\treturn when(val, function (value) {\n\t\t\t\t\t\treturn reduceFunc(c, value, i, total);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t};\n\n\t\t\treturn reduceArray.apply(array, args);\n\t\t});\n\t}\n\n\t// Snapshot states\n\n\t/**\n\t * Creates a fulfilled state snapshot\n\t * @private\n\t * @param {*} x any value\n\t * @returns {{state:'fulfilled',value:*}}\n\t */\n\tfunction toFulfilledState(x) {\n\t\treturn { state: 'fulfilled', value: x };\n\t}\n\n\t/**\n\t * Creates a rejected state snapshot\n\t * @private\n\t * @param {*} x any reason\n\t * @returns {{state:'rejected',reason:*}}\n\t */\n\tfunction toRejectedState(x) {\n\t\treturn { state: 'rejected', reason: x };\n\t}\n\n\t/**\n\t * Creates a pending state snapshot\n\t * @private\n\t * @returns {{state:'pending'}}\n\t */\n\tfunction toPendingState() {\n\t\treturn { state: 'pending' };\n\t}\n\n\t//\n\t// Internals, utilities, etc.\n\t//\n\n\tvar promisePrototype, makePromisePrototype, reduceArray, slice, fcall, nextTick, handlerQueue,\n\t\tfuncProto, call, arrayProto, monitorApi,\n\t\tcapturedSetTimeout, cjsRequire, MutationObs, undef;\n\n\tcjsRequire = require;\n\n\t//\n\t// Shared handler queue processing\n\t//\n\t// Credit to Twisol (https://github.com/Twisol) for suggesting\n\t// this type of extensible queue + trampoline approach for\n\t// next-tick conflation.\n\n\thandlerQueue = [];\n\n\t/**\n\t * Enqueue a task. If the queue is not currently scheduled to be\n\t * drained, schedule it.\n\t * @param {function} task\n\t */\n\tfunction enqueue(task) {\n\t\tif(handlerQueue.push(task) === 1) {\n\t\t\tnextTick(drainQueue);\n\t\t}\n\t}\n\n\t/**\n\t * Drain the handler queue entirely, being careful to allow the\n\t * queue to be extended while it is being processed, and to continue\n\t * processing until it is truly empty.\n\t */\n\tfunction drainQueue() {\n\t\trunHandlers(handlerQueue);\n\t\thandlerQueue = [];\n\t}\n\n\t// Allow attaching the monitor to when() if env has no console\n\tmonitorApi = typeof console !== 'undefined' ? console : when;\n\n\t// Sniff \"best\" async scheduling option\n\t// Prefer process.nextTick or MutationObserver, then check for\n\t// vertx and finally fall back to setTimeout\n\t/*global process,document,setTimeout,MutationObserver,WebKitMutationObserver*/\n\tif (typeof process === 'object' && process.nextTick) {\n\t\tnextTick = process.nextTick;\n\t} else if(MutationObs =\n\t\t(typeof MutationObserver === 'function' && MutationObserver) ||\n\t\t\t(typeof WebKitMutationObserver === 'function' && WebKitMutationObserver)) {\n\t\tnextTick = (function(document, MutationObserver, drainQueue) {\n\t\t\tvar el = document.createElement('div');\n\t\t\tnew MutationObserver(drainQueue).observe(el, { attributes: true });\n\n\t\t\treturn function() {\n\t\t\t\tel.setAttribute('x', 'x');\n\t\t\t};\n\t\t}(document, MutationObs, drainQueue));\n\t} else {\n\t\ttry {\n\t\t\t// vert.x 1.x || 2.x\n\t\t\tnextTick = cjsRequire('vertx').runOnLoop || cjsRequire('vertx').runOnContext;\n\t\t} catch(ignore) {\n\t\t\t// capture setTimeout to avoid being caught by fake timers\n\t\t\t// used in time based tests\n\t\t\tcapturedSetTimeout = setTimeout;\n\t\t\tnextTick = function(t) { capturedSetTimeout(t, 0); };\n\t\t}\n\t}\n\n\t//\n\t// Capture/polyfill function and array utils\n\t//\n\n\t// Safe function calls\n\tfuncProto = Function.prototype;\n\tcall = funcProto.call;\n\tfcall = funcProto.bind\n\t\t? call.bind(call)\n\t\t: function(f, context) {\n\t\t\treturn f.apply(context, slice.call(arguments, 2));\n\t\t};\n\n\t// Safe array ops\n\tarrayProto = [];\n\tslice = arrayProto.slice;\n\n\t// ES5 reduce implementation if native not available\n\t// See: http://es5.github.com/#x15.4.4.21 as there are many\n\t// specifics and edge cases.  ES5 dictates that reduce.length === 1\n\t// This implementation deviates from ES5 spec in the following ways:\n\t// 1. It does not check if reduceFunc is a Callable\n\treduceArray = arrayProto.reduce ||\n\t\tfunction(reduceFunc /*, initialValue */) {\n\t\t\t/*jshint maxcomplexity: 7*/\n\t\t\tvar arr, args, reduced, len, i;\n\n\t\t\ti = 0;\n\t\t\tarr = Object(this);\n\t\t\tlen = arr.length >>> 0;\n\t\t\targs = arguments;\n\n\t\t\t// If no initialValue, use first item of array (we know length !== 0 here)\n\t\t\t// and adjust i to start at second item\n\t\t\tif(args.length <= 1) {\n\t\t\t\t// Skip to the first real element in the array\n\t\t\t\tfor(;;) {\n\t\t\t\t\tif(i in arr) {\n\t\t\t\t\t\treduced = arr[i++];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If we reached the end of the array without finding any real\n\t\t\t\t\t// elements, it's a TypeError\n\t\t\t\t\tif(++i >= len) {\n\t\t\t\t\t\tthrow new TypeError();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If initialValue provided, use it\n\t\t\t\treduced = args[1];\n\t\t\t}\n\n\t\t\t// Do the actual reduce\n\t\t\tfor(;i < len; ++i) {\n\t\t\t\tif(i in arr) {\n\t\t\t\t\treduced = reduceFunc(reduced, arr[i], i, arr);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn reduced;\n\t\t};\n\n\tfunction identity(x) {\n\t\treturn x;\n\t}\n\n\tfunction crash(fatalError) {\n\t\tif(typeof monitorApi.reportUnhandled === 'function') {\n\t\t\tmonitorApi.reportUnhandled();\n\t\t} else {\n\t\t\tenqueue(function() {\n\t\t\t\tthrow fatalError;\n\t\t\t});\n\t\t}\n\n\t\tthrow fatalError;\n\t}\n\n\treturn when;\n});\n})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}