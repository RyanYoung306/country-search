{"ast":null,"code":"var _ = require('lodash'),\n  path = require('path'),\n  glob = require('glob'),\n  minimatch = require('minimatch'),\n  fs = require('fs');\nvar SCATTER_FILE_NAME = 'particle.json';\nvar DEFAULT_EXCLUDE = ['**/.*', 'node_modules'];\nfunction Resolver(options) {\n  this.particles = {};\n  this.particlesOrder = [];\n  this.isSorted = false;\n  this.log = options.log;\n}\n\n/**\n * Transforms an array of globbed paths, in an array of scattered roots\n */\nResolver.prototype._expandPaths = function (globs, basePath) {\n  var self = this;\n  if (_.isString(globs)) {\n    globs = [globs];\n  }\n  var paths = [];\n  _.each(globs, function (globbedPath) {\n    if (basePath) {\n      globbedPath = path.join(basePath, globbedPath);\n    }\n    var currentPaths = glob.sync(globbedPath);\n    if (_.isEmpty(currentPaths)) {\n      self.log('warn', \"No particles added for \" + globbedPath);\n    }\n    Array.prototype.push.apply(paths, currentPaths);\n  });\n  return paths;\n};\n\n/**\n * Add particles to the list of roots\n * @param particlesPaths\n * @param basePath [optional]\n */\nResolver.prototype.registerParticles = function (particlesPaths, basePath) {\n  var self = this;\n  particlesPaths = self._expandPaths(particlesPaths, basePath);\n  _.each(particlesPaths, function (particlePath) {\n    //check the descriptor\n    var descriptorFileName = path.join(particlePath, SCATTER_FILE_NAME);\n    if (!fs.existsSync(descriptorFileName)) {\n      throw new Error(\"Scatter particle descriptor (\" + SCATTER_FILE_NAME + \") not found in \" + particlePath);\n    }\n    var descriptor = require(descriptorFileName);\n    if (!descriptor.subparticles && !descriptor.name) {\n      throw new Error(\"Component `name` or `subparticles` required in \" + descriptorFileName);\n    }\n    if (descriptor.subparticles) {\n      self.registerParticles(descriptor.subparticles, particlePath);\n    } else {\n      self.log('info', \"Registering particle at \" + particlePath);\n      //use the package directory\n      self._addComponent(particlePath, descriptor);\n      self.isSorted = false;\n    }\n  });\n};\nResolver.prototype._addComponent = function (particlePath, descriptor) {\n  var self = this;\n  //normalize the descriptor\n\n  //normalize exclude\n  descriptor.exclude = descriptor.exclude || [];\n  Array.prototype.push.apply(descriptor.exclude, DEFAULT_EXCLUDE);\n\n  //to be used for grunt watch develop\n  descriptor.excludeFull = _.map(descriptor.exclude, function (exclude) {\n    return \"!\" + path.join(particlePath, exclude);\n  });\n  self.particles[descriptor.name] = {\n    root: particlePath,\n    descriptor: descriptor\n  };\n};\nResolver.prototype._sortComponents = function () {\n  var self = this;\n  //keep dependencies somewhere\n  var dependencies = {};\n  var noDependencies = [];\n  //initialize deps\n  _.each(self.particles, function (particle, name) {\n    if (_.isEmpty(particle.descriptor.overrides)) {\n      noDependencies.push(name);\n    } else {\n      var deps = {};\n      _.each(particle.descriptor.overrides, function (dep) {\n        deps[dep] = true;\n      });\n      dependencies[name] = deps;\n    }\n  });\n  noDependencies = _.uniq(noDependencies);\n  self.particlesOrder = [];\n  while (noDependencies.length !== 0) {\n    var currentName = noDependencies.shift();\n    self.particlesOrder.push(currentName);\n    _.each(dependencies, function (deps, name) {\n      if (deps[currentName]) {\n        delete deps[currentName];\n        if (_.isEmpty(deps)) {\n          noDependencies.push(name);\n          delete dependencies[name];\n        }\n      }\n    });\n  }\n  if (!_.isEmpty(dependencies)) {\n    self.log('warn', \"There is a loop or missing requirement in the particles dependencies\", dependencies);\n    //add orphaned particles\n    _.each(dependencies, function (deps, name) {\n      self.particlesOrder.push(name);\n    });\n  }\n\n  //It's a dependent->dependency relationship, but in our list dependent should come BEFORE the dependency!\n  self.particlesOrder.reverse();\n  self.isSorted = true;\n};\n\n/**\n * Set the node_modules dir so it npm modules can be required with npm! and\n * scan the modules to find scatter particles\n *\n * @param nodeModulesDir\n * @param exclude a set of modules to exclude (no glob)\n */\nResolver.prototype.setNodeModulesDir = function (nodeModulesDir, exclude) {\n  var self = this;\n  this.nodeModulesDir = nodeModulesDir;\n\n  //Look into particle.json and extract the scatter exports\n  var packages = self._expandPaths(path.join(nodeModulesDir, \"*\")).filter(function (root) {\n    var name = path.basename(root);\n    return !_.contains(exclude, name) && fs.existsSync(path.join(root, SCATTER_FILE_NAME));\n  });\n  self.registerParticles(packages);\n};\nResolver.prototype.isIgnored = function (rootObj, file) {\n  return _.any(rootObj.descriptor.exclude, function (ignore) {\n    return minimatch(file, ignore);\n  });\n};\nResolver.prototype.iterateParticles = function (callback) {\n  var self = this;\n  self.isSorted || self._sortComponents();\n  _.any(self.particlesOrder, function (particlePosition) {\n    return callback(self.particles[particlePosition]);\n  });\n};\n\n/**\n * Resolves a single module\n *\n * @param name\n * @returns {*}\n */\nResolver.prototype.resolveModule = function (name, overrideComponent) {\n  var self = this;\n  var mod;\n  var overrideFound = false;\n  self.iterateParticles(function (particle) {\n    var filename = name + '.js';\n    var fullpath = path.join(particle.root, filename);\n    if (!self.isIgnored(particle, filename) && fs.existsSync(fullpath) && fs.statSync(fullpath).isFile()) {\n      if (!overrideFound && overrideComponent) {\n        overrideFound = overrideComponent.descriptor.name === particle.descriptor.name;\n      } else {\n        mod = {\n          rawModule: require(fullpath),\n          particle: particle\n        };\n        return true;\n      }\n    }\n  });\n  return mod;\n};\n\n/**\n * require a module from node_modules\n *\n * @param name\n * @returns The module\n */\nResolver.prototype.requireNpm = function (name) {\n  var self = this;\n  var file = path.join(self.nodeModulesDir, name + '.js');\n  if (fs.existsSync(file)) {\n    return require(file);\n  }\n  file = path.join(self.nodeModulesDir, name, 'index.js');\n  if (fs.existsSync(file)) {\n    return require(file);\n  }\n  var packagejson = path.join(self.nodeModulesDir, name, 'package.json');\n  if (fs.existsSync(packagejson)) {\n    var main = require(packagejson).main;\n    var mainName = path.join(path.dirname(main), path.basename(main, '.js'));\n    file = path.join(self.nodeModulesDir, name, mainName + '.js');\n    if (fs.existsSync(file)) {\n      return require(file);\n    }\n    file = path.join(self.nodeModulesDir, name, mainName, 'index.js');\n    if (fs.existsSync(file)) {\n      return require(file);\n    }\n  }\n  throw new Error(\"Cannot find npm module '\" + name + \"'\");\n};\nResolver.prototype.resolveAllInParticle = function (particle, subpath) {\n  var self = this;\n  subpath = subpath || \"\";\n  var modules = {};\n  var fullPath = path.join(particle.root, subpath);\n  if (!self.isIgnored(particle, subpath)) {\n    if (fs.existsSync(fullPath)) {\n      var stat = fs.statSync(fullPath);\n      if (stat.isFile()) {\n        if (path.extname(fullPath) === \".js\") {\n          var modName = subpath.substring(0, subpath.lastIndexOf('.js')).replace(/\\\\/g, '/');\n          modules[modName] = {\n            rawModule: require(fullPath),\n            particle: particle\n          };\n        }\n      } else if (stat.isDirectory()) {\n        var files = fs.readdirSync(fullPath);\n        _.each(files, function (file) {\n          _.defaults(modules, self.resolveAllInParticle(particle, path.join(subpath, file)));\n        });\n      }\n    }\n  }\n  return modules;\n};\n\n/**\n * Resolves all modules in a namespace\n *\n * @param scope\n * @returns {*}\n */\nResolver.prototype.resolveAll = function (scope) {\n  var self = this;\n  scope = scope || '';\n  var modules = {};\n\n  //get the project's files\n  self.iterateParticles(function (particle) {\n    _.defaults(modules, self.resolveAllInParticle(particle, scope));\n  });\n  return modules;\n};\nmodule.exports = Resolver;","map":{"version":3,"names":["_","require","path","glob","minimatch","fs","SCATTER_FILE_NAME","DEFAULT_EXCLUDE","Resolver","options","particles","particlesOrder","isSorted","log","prototype","_expandPaths","globs","basePath","self","isString","paths","each","globbedPath","join","currentPaths","sync","isEmpty","Array","push","apply","registerParticles","particlesPaths","particlePath","descriptorFileName","existsSync","Error","descriptor","subparticles","name","_addComponent","exclude","excludeFull","map","root","_sortComponents","dependencies","noDependencies","particle","overrides","deps","dep","uniq","length","currentName","shift","reverse","setNodeModulesDir","nodeModulesDir","packages","filter","basename","contains","isIgnored","rootObj","file","any","ignore","iterateParticles","callback","particlePosition","resolveModule","overrideComponent","mod","overrideFound","filename","fullpath","statSync","isFile","rawModule","requireNpm","packagejson","main","mainName","dirname","resolveAllInParticle","subpath","modules","fullPath","stat","extname","modName","substring","lastIndexOf","replace","isDirectory","files","readdirSync","defaults","resolveAll","scope","module","exports"],"sources":["C:/Users/twotr/Desktop/College/vsCode/WorkHumanApplication/country-search/node_modules/scatter/lib/Resolver.js"],"sourcesContent":["var _ = require('lodash'),\n  path = require('path'),\n  glob = require('glob'),\n  minimatch = require('minimatch'),\n  fs = require('fs');\n\n\nvar SCATTER_FILE_NAME = 'particle.json';\nvar DEFAULT_EXCLUDE = ['**/.*', 'node_modules'];\n\n\nfunction Resolver(options) {\n  this.particles = {};\n  this.particlesOrder = [];\n  this.isSorted = false;\n\n  this.log = options.log;\n}\n\n/**\n * Transforms an array of globbed paths, in an array of scattered roots\n */ \nResolver.prototype._expandPaths = function(globs, basePath) {\n  var self = this;\n  if(_.isString(globs)) {\n    globs = [globs];\n  }\n\n  var paths = [];\n  _.each(globs, function(globbedPath) {\n    if(basePath) {\n      globbedPath = path.join(basePath, globbedPath);\n    }\n    var currentPaths = glob.sync(globbedPath);\n    if(_.isEmpty(currentPaths)) {\n      self.log('warn', \"No particles added for \" + globbedPath);\n    }\n    Array.prototype.push.apply(paths, currentPaths);\n  });\n  return paths;\n};\n\n/**\n * Add particles to the list of roots\n * @param particlesPaths\n * @param basePath [optional]\n */\nResolver.prototype.registerParticles = function(particlesPaths, basePath) {\n  var self = this;\n  particlesPaths = self._expandPaths(particlesPaths, basePath);\n\n  _.each(particlesPaths, function(particlePath) {\n    //check the descriptor\n    var descriptorFileName = path.join(particlePath, SCATTER_FILE_NAME);\n    if(!fs.existsSync(descriptorFileName)) {\n      throw new Error(\"Scatter particle descriptor (\"+SCATTER_FILE_NAME+\") not found in \" + particlePath);\n    }\n    var descriptor = require(descriptorFileName);\n    if(!descriptor.subparticles && !descriptor.name) {\n      throw new Error(\"Component `name` or `subparticles` required in \" + descriptorFileName);\n    }\n\n    if(descriptor.subparticles) {\n      self.registerParticles(descriptor.subparticles, particlePath);\n    } else {\n      self.log('info', \"Registering particle at \" + particlePath);\n      //use the package directory\n      self._addComponent(particlePath, descriptor);\n      self.isSorted = false;\n    }\n  });\n};\n\n\nResolver.prototype._addComponent = function(particlePath, descriptor) {\n  var self = this;\n  //normalize the descriptor\n  \n  //normalize exclude\n  descriptor.exclude = descriptor.exclude || [];\n  Array.prototype.push.apply(descriptor.exclude, DEFAULT_EXCLUDE);\n  \n  //to be used for grunt watch develop\n  descriptor.excludeFull = _.map(descriptor.exclude, function(exclude) {\n    return \"!\" + path.join(particlePath, exclude);\n  });\n  \n  self.particles[descriptor.name] = {\n    root: particlePath,\n    descriptor: descriptor\n  };\n};\n\n\nResolver.prototype._sortComponents = function() {\n  var self = this;\n  //keep dependencies somewhere\n  var dependencies = {};\n  var noDependencies = [];\n  //initialize deps\n  _.each(self.particles, function(particle, name) {\n    if(_.isEmpty(particle.descriptor.overrides)) {\n      noDependencies.push(name);\n    } else {\n      var deps = {};\n      _.each(particle.descriptor.overrides, function(dep) {\n        deps[dep] = true;\n      });\n      dependencies[name] = deps;\n    }\n  });\n  noDependencies = _.uniq(noDependencies);\n\n  self.particlesOrder = [];\n  while(noDependencies.length !== 0) {\n    var currentName = noDependencies.shift();\n    self.particlesOrder.push(currentName);\n    _.each(dependencies, function(deps, name) {\n      if(deps[currentName]) {\n        delete deps[currentName];\n        if(_.isEmpty(deps)) {\n          noDependencies.push(name);\n          delete dependencies[name];\n        }\n      }\n    });\n  }\n\n  if(!_.isEmpty(dependencies)) {\n    self.log('warn', \"There is a loop or missing requirement in the particles dependencies\", dependencies);\n    //add orphaned particles\n    _.each(dependencies, function(deps, name) {\n      self.particlesOrder.push(name);\n    });\n  }\n  \n  //It's a dependent->dependency relationship, but in our list dependent should come BEFORE the dependency!\n  self.particlesOrder.reverse();\n  self.isSorted = true;\n};\n\n/**\n * Set the node_modules dir so it npm modules can be required with npm! and\n * scan the modules to find scatter particles\n *\n * @param nodeModulesDir\n * @param exclude a set of modules to exclude (no glob)\n */\nResolver.prototype.setNodeModulesDir = function(nodeModulesDir, exclude) {\n  var self = this;\n  this.nodeModulesDir = nodeModulesDir;\n\n  //Look into particle.json and extract the scatter exports\n  var packages = self._expandPaths(path.join(nodeModulesDir, \"*\"))\n    .filter(function(root) {\n      var name = path.basename(root);\n      return !_.contains(exclude, name) && fs.existsSync(path.join(root, SCATTER_FILE_NAME));\n    });\n  self.registerParticles(packages);\n};\n\n\nResolver.prototype.isIgnored = function(rootObj, file) {\n  return _.any(rootObj.descriptor.exclude, function(ignore) {\n    return minimatch(file, ignore);\n  });\n};\n\n\nResolver.prototype.iterateParticles = function(callback) {\n  var self = this;\n  self.isSorted || self._sortComponents();\n  _.any(self.particlesOrder, function(particlePosition) {\n    return callback(self.particles[particlePosition]);\n  });\n};\n\n/**\n * Resolves a single module\n *\n * @param name\n * @returns {*}\n */\nResolver.prototype.resolveModule = function(name, overrideComponent) {\n  var self = this;\n  var mod;\n  \n  var overrideFound = false;\n  self.iterateParticles(function(particle) {\n    var filename = name + '.js';\n    var fullpath = path.join(particle.root, filename);\n    if(!self.isIgnored(particle, filename) &&\n      fs.existsSync(fullpath) &&\n      fs.statSync(fullpath).isFile()) \n    {\n      if(!overrideFound && overrideComponent) {\n        overrideFound = overrideComponent.descriptor.name === particle.descriptor.name;\n      } else {\n        mod = {\n          rawModule: require(fullpath),\n          particle: particle\n        };\n        return true;\n      }\n    }\n  });\n  \n  return mod;\n};\n\n/**\n * require a module from node_modules\n *\n * @param name\n * @returns The module\n */\nResolver.prototype.requireNpm = function(name) {\n  var self = this;\n  var file = path.join(self.nodeModulesDir, name + '.js');\n  if(fs.existsSync(file)) {\n    return require(file);\n  }\n  file = path.join(self.nodeModulesDir, name, 'index.js');\n  if(fs.existsSync(file)) {\n    return require(file);\n  }\n  var packagejson = path.join(self.nodeModulesDir, name, 'package.json');\n  if(fs.existsSync(packagejson)) {\n    var main = require(packagejson).main;\n    var mainName = path.join(path.dirname(main), path.basename(main, '.js'));\n    file = path.join(self.nodeModulesDir, name, mainName+'.js');\n    if(fs.existsSync(file)) {\n      return require(file);\n    }\n    \n    file = path.join(self.nodeModulesDir, name, mainName, 'index.js');\n    if(fs.existsSync(file)) {\n      return require(file);\n    }\n  }\n  \n  throw new Error(\"Cannot find npm module '\" + name + \"'\");\n};\n\n\nResolver.prototype.resolveAllInParticle = function(particle, subpath) {\n  var self = this;\n  subpath = subpath || \"\";\n  var modules = {};\n  var fullPath = path.join(particle.root, subpath);\n  \n  if(!self.isIgnored(particle, subpath)) {\n    if(fs.existsSync(fullPath)) {\n      var stat = fs.statSync(fullPath);\n      if(stat.isFile()) {\n        if(path.extname(fullPath) === \".js\") {\n          var modName = subpath.substring(0, subpath.lastIndexOf('.js')).replace(/\\\\/g, '/');\n          modules[modName] = {\n            rawModule: require(fullPath),\n            particle: particle\n          };\n        }\n      } else if(stat.isDirectory()) {\n        var files = fs.readdirSync(fullPath);\n        _.each(files, function(file) {\n          _.defaults(modules, self.resolveAllInParticle(particle, path.join(subpath, file)));\n        });\n      }\n    }\n  }\n  \n  return modules;\n};\n\n/**\n * Resolves all modules in a namespace\n *\n * @param scope\n * @returns {*}\n */\nResolver.prototype.resolveAll = function(scope) {\n  var self = this;\n  scope = scope || '';\n  var modules = {};\n  \n  //get the project's files\n  self.iterateParticles(function(particle) {\n    _.defaults(modules, self.resolveAllInParticle(particle, scope));\n  });\n  return modules;\n};\n\nmodule.exports = Resolver;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}